# /// script
# /// requires-python = ">=3.10"
# /// dependencies = []
# ///
"""Convert a Loom stimulus VCD to Verilog timed assignments for CVC.

Reads the stimulus VCD (generated by `loom cosim --stimulus-vcd`) and produces
a Verilog include file with delay-based `initial begin ... end` blocks that
drive the DUT ports.

Usage:
    uv run tests/mcu_soc/cvc/convert_stimulus.py \
        tests/mcu_soc/cvc/stimulus.vcd \
        tests/mcu_soc/cvc/stimulus_gen.v
"""

import re
import sys
from pathlib import Path


def parse_vcd(vcd_path: Path) -> tuple[dict[str, str], list[tuple[int, list[tuple[str, int]]]]]:
    """Parse a VCD file, return (id_to_name, timestamps_with_changes).

    Returns:
        id_to_name: mapping from VCD ID code to signal name
        events: list of (timestamp, [(id, value), ...])
    """
    id_to_name: dict[str, str] = {}
    events: list[tuple[int, list[tuple[str, int]]]] = []

    in_header = True
    current_ts = 0
    current_changes: list[tuple[str, int]] = []

    with open(vcd_path) as f:
        for line in f:
            line = line.strip()
            if not line:
                continue

            if in_header:
                # Parse variable definitions
                m = re.match(r'\$var\s+\w+\s+\d+\s+(\S+)\s+(.+?)\s*\$end', line)
                if m:
                    vid, name = m.group(1), m.group(2)
                    # Normalize "gpio_in [38]" â†’ "gpio_in[38]" (remove space
                    # between name and bit select that vcd-ng adds).
                    # Also handle redundant trailing index like "signal[0] [0]"
                    # by collapsing to just "signal[0]".
                    name = re.sub(r'\s+\[(\d+)\]$', r'[\1]', name)
                    id_to_name[vid] = name
                elif line.startswith('$enddefinitions'):
                    in_header = False
                continue

            # Parse timestamps and value changes
            if line.startswith('#'):
                if current_changes:
                    events.append((current_ts, current_changes))
                    current_changes = []
                current_ts = int(line[1:])
            elif line.startswith('$'):
                # Skip $dumpvars, $end, etc.
                continue
            elif len(line) >= 2 and line[0] in '01xXzZ':
                val = 1 if line[0] == '1' else 0
                vid = line[1:]
                current_changes.append((vid, val))

    if current_changes:
        events.append((current_ts, current_changes))

    return id_to_name, events


def map_signals_to_ports(id_to_name: dict[str, str]) -> dict[str, tuple[str, int | None]]:
    """Map VCD signal names to (port_name, bit_index) pairs.

    E.g., "gpio_in[5]" -> ("gpio_in", 5)
          "por_l" -> ("por_l", None)
    """
    result: dict[str, tuple[str, int | None]] = {}
    for vid, name in id_to_name.items():
        m = re.match(r'(.+)\[(\d+)\]$', name)
        if m:
            result[vid] = (m.group(1), int(m.group(2)))
        else:
            result[vid] = (name, None)
    return result


    # Ports that are inout or shouldn't be driven from stimulus
EXCLUDED_PORTS = {'analog_io', 'analog_noesd_io'}


def generate_verilog(
    id_to_name: dict[str, str],
    events: list[tuple[int, list[tuple[str, int]]]],
    output_path: Path,
) -> None:
    """Generate Verilog stimulus file with timed assignments."""
    port_map = map_signals_to_ports(id_to_name)

    # Collect all unique ports and their widths
    port_widths: dict[str, int] = {}  # port_name -> max bit index + 1
    scalar_ports: set[str] = set()
    for _vid, (port_name, bit_idx) in port_map.items():
        if port_name in EXCLUDED_PORTS:
            continue
        if bit_idx is not None:
            port_widths[port_name] = max(port_widths.get(port_name, 0), bit_idx + 1)
        else:
            scalar_ports.add(port_name)

    with open(output_path, 'w') as f:
        f.write("// Auto-generated stimulus from Loom cosim VCD\n")
        f.write(f"// Source: stimulus.vcd\n")
        f.write(f"// Signals: {len(id_to_name)}, Events: {len(events)}\n")
        f.write(f"// Ports: {sorted(port_widths.keys())} + {sorted(scalar_ports)}\n\n")

        f.write("initial begin\n")

        prev_ts = 0
        for ts, changes in events:
            delay = ts - prev_ts
            if delay > 0:
                f.write(f"  #{delay};\n")
            elif ts == 0 and prev_ts == 0:
                pass  # no delay for initial
            prev_ts = ts

            # Group changes by port for readability
            for vid, val in changes:
                if vid not in port_map:
                    continue
                port_name, bit_idx = port_map[vid]
                if port_name in EXCLUDED_PORTS:
                    continue
                val_str = f"1'b{val}"
                if bit_idx is not None:
                    f.write(f"  {port_name}[{bit_idx}] = {val_str};\n")
                else:
                    f.write(f"  {port_name} = {val_str};\n")

        # Add finish after last event + one more clock period
        f.write("  #80000;\n")
        f.write("  $finish;\n")
        f.write("end\n")

    total_changes = sum(len(c) for _, c in events)
    print(f"Generated {output_path}: {len(events)} timestamps, {total_changes} value changes")
    print(f"  Bus ports: {dict(sorted(port_widths.items()))}")
    print(f"  Scalar ports: {sorted(scalar_ports)}")


def main() -> None:
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <stimulus.vcd> <output.v>", file=sys.stderr)
        sys.exit(1)

    vcd_path = Path(sys.argv[1])
    output_path = Path(sys.argv[2])

    if not vcd_path.exists():
        print(f"Error: {vcd_path} not found", file=sys.stderr)
        sys.exit(1)

    id_to_name, events = parse_vcd(vcd_path)
    print(f"Parsed {vcd_path}: {len(id_to_name)} signals, {len(events)} timestamps")

    generate_verilog(id_to_name, events, output_path)


if __name__ == '__main__':
    main()
