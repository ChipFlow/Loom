<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adding a New PDK - Loom Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Loom Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ChipFlow/Loom" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="adding-a-new-pdk-for-post-layout-simulation"><a class="header" href="#adding-a-new-pdk-for-post-layout-simulation">Adding a New PDK for Post-Layout Simulation</a></h1>
<p>This guide documents the process of enabling a new process design kit (PDK) for
gate-level simulation in Loom. It is based on the SKY130 enablement and captures
every integration point.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Loom natively supports AIGPDK (its own synthesis library of AND gates, DFFs, and
SRAMs). Supporting a foundry PDK like SKY130 requires teaching the simulator how
to interpret the PDK's standard cells: their pin directions, their boolean
function, and which ones are sequential.</p>
<p>The integration touches five areas:</p>
<ol>
<li><strong>Library detection</strong> -- recognizing cell names from a netlist</li>
<li><strong>Pin direction provider</strong> -- telling the netlist parser which pins are inputs/outputs</li>
<li><strong>Cell classification</strong> -- identifying sequential, tie, and multi-output cells</li>
<li><strong>Behavioral decomposition</strong> -- converting PDK cells to AIG (AND/NOT) primitives</li>
<li><strong>CLI wiring</strong> -- connecting it all together</li>
</ol>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>You need:</p>
<ul>
<li>The PDK's Verilog cell library (behavioral or functional models)</li>
<li>A post-synthesis or post-P&amp;R netlist using those cells</li>
<li>The cell naming convention (prefix, drive strength suffix format)</li>
</ul>
<p>For SKY130, the PDK data lives in <code>vendor/sky130_fd_sc_hd/</code> as a git submodule.</p>
<h2 id="step-1-library-detection"><a class="header" href="#step-1-library-detection">Step 1: Library Detection</a></h2>
<p><strong>Reference</strong>: <code>src/sky130.rs</code> -- <code>is_sky130_cell()</code>, <code>detect_library()</code>,
<code>detect_library_from_file()</code></p>
<p>Loom scans the netlist to determine which cell library is in use. Each PDK needs
a name-matching function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/sky130.rs:535
pub fn is_sky130_cell(name: &amp;str) -&gt; bool {
    name.starts_with("sky130_fd_sc_")
        || name.starts_with("CF_SRAM_")
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>CellLibrary</code> enum tracks known libraries. <code>detect_library()</code> iterates cell
names and returns the detected library (or <code>Mixed</code> if cells from multiple
libraries are found -- this is an error).</p>
<p><strong>For a new PDK</strong>: Add a variant to <code>CellLibrary</code>, write an <code>is_&lt;pdk&gt;_cell()</code>
function, and update <code>detect_library()</code>.</p>
<h2 id="step-2-cell-type-extraction"><a class="header" href="#step-2-cell-type-extraction">Step 2: Cell Type Extraction</a></h2>
<p><strong>Reference</strong>: <code>src/sky130.rs</code> -- <code>extract_cell_type()</code></p>
<p>PDK cell names follow a convention: <code>&lt;prefix&gt;__&lt;type&gt;_&lt;drive&gt;</code>. The simulator
needs to strip the prefix and drive strength to get the base cell type:</p>
<pre><code>sky130_fd_sc_hd__nand2_4  --&gt;  nand2
sky130_fd_sc_hd__dfxtp_1  --&gt;  dfxtp
</code></pre>
<p>This function must handle all library variants (hd, hs, ms, ls, lp, hdll, hvl
for SKY130) and any custom macros (CF_SRAM_*).</p>
<p><strong>For a new PDK</strong>: Write an equivalent <code>extract_cell_type()</code> for the PDK's
naming scheme.</p>
<h2 id="step-3-pin-direction-provider"><a class="header" href="#step-3-pin-direction-provider">Step 3: Pin Direction Provider</a></h2>
<p><strong>Reference</strong>: <code>src/sky130.rs</code> -- <code>SKY130LeafPins</code> implementing <code>LeafPinProvider</code></p>
<p>The netlist parser (from <code>eda-infra-rs/netlistdb</code>) needs to know pin
directions and widths for every cell type. This is implemented as a trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl LeafPinProvider for SKY130LeafPins {
    fn direction_of(&amp;self, macro_name, pin_name, pin_idx) -&gt; Direction;
    fn width_of(&amp;self, macro_name, pin_name) -&gt; Option&lt;SVerilogRange&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>For SKY130, <code>direction_of()</code> is a large match statement covering ~80 cell types
with all their pin names. This is tedious but straightforward -- for each cell,
list which pins are inputs and which are outputs.</p>
<p><strong>Sources for pin directions</strong>:</p>
<ul>
<li>The PDK's Liberty (.lib) files list pin directions</li>
<li>The PDK's behavioral Verilog models declare <code>input</code>/<code>output</code> ports</li>
<li>LEF files also contain pin direction information</li>
</ul>
<p><strong>For a new PDK</strong>: Implement the trait for all cells that appear in your target
netlists. You can start with just the cells used in your design and add others
as needed.</p>
<h2 id="step-4-cell-classification"><a class="header" href="#step-4-cell-classification">Step 4: Cell Classification</a></h2>
<p><strong>Reference</strong>: <code>src/sky130_pdk.rs</code> -- <code>is_sequential_cell()</code>, <code>is_tie_cell()</code>,
<code>is_multi_output_cell()</code></p>
<p>Three classification functions control how cells are processed during AIG
construction:</p>
<h3 id="sequential-cells-dffs-and-latches"><a class="header" href="#sequential-cells-dffs-and-latches">Sequential cells (DFFs and latches)</a></h3>
<p>These are handled specially in the AIG builder -- their outputs become state
elements rather than combinational logic.</p>
<p><strong>Critical</strong>: Use an explicit whitelist, not prefix matching. PDK naming
collisions will silently break simulation if you guess wrong (e.g., SKY130's
<code>dlygate4sd3</code> starts with "dl" but is a combinational delay buffer, not a
latch).</p>
<p><strong>Derivation method</strong>: Grep the PDK's behavioral Verilog models for DFF/latch
primitives:</p>
<pre><code class="language-bash">for cell in $(ls vendor/&lt;pdk&gt;/cells/); do
    vfile="vendor/&lt;pdk&gt;/cells/$cell/&lt;pdk&gt;__${cell}.behavioral.v"
    if [ -f "$vfile" ] &amp;&amp; grep -qE 'udp_dff|udp_dlatch' "$vfile"; then
        echo "$cell"
    fi
done
</code></pre>
<p>For PDKs that don't use Verilog UDPs, look for <code>always @(posedge</code> blocks or
check the Liberty file's <code>ff</code> and <code>latch</code> groups.</p>
<h3 id="tie-cells"><a class="header" href="#tie-cells">Tie cells</a></h3>
<p>Cells that produce constant 0 or 1 (e.g., SKY130's <code>conb</code> with HI/LO pins).</p>
<h3 id="multi-output-cells"><a class="header" href="#multi-output-cells">Multi-output cells</a></h3>
<p>Cells with more than one output (e.g., half-adder <code>ha</code> with SUM and COUT,
full-adder <code>fa</code>). These need special handling because the AIG builder processes
one output pin at a time.</p>
<h2 id="step-5-behavioral-model-loading"><a class="header" href="#step-5-behavioral-model-loading">Step 5: Behavioral Model Loading</a></h2>
<p><strong>Reference</strong>: <code>src/sky130_pdk.rs</code> -- <code>load_pdk_models()</code>, <code>parse_functional_model()</code>,
<code>parse_udp()</code></p>
<p>Loom decomposes PDK cells to AIG primitives (AND gates and inversions) by
parsing their functional Verilog models. The expected file structure:</p>
<pre><code>vendor/&lt;pdk&gt;/
  cells/
    &lt;cell_type&gt;/
      &lt;pdk&gt;__&lt;cell_type&gt;.functional.v    # Gate-level behavioral model
  models/
    &lt;udp_name&gt;/
      &lt;pdk&gt;__&lt;udp_name&gt;.v               # Verilog UDP definitions
</code></pre>
<h3 id="functional-models"><a class="header" href="#functional-models">Functional models</a></h3>
<p>These are gate-level Verilog using primitives like <code>and</code>, <code>or</code>, <code>nand</code>, <code>nor</code>,
<code>not</code>, <code>xor</code>, <code>xnor</code>, <code>buf</code>. The parser (<code>parse_functional_model()</code>) extracts
these into a topologically-ordered list of <code>BehavioralGate</code> structures.</p>
<p>Example (<code>sky130_fd_sc_hd__o21ai.functional.v</code>):</p>
<pre><code class="language-verilog">module sky130_fd_sc_hd__o21ai (Y, A1, A2, B1);
    output Y;
    input  A1, A2, B1;
    wire or0_out;
    or  or0  (or0_out, A2, A1);
    nand nand0 (Y, B1, or0_out);
endmodule
</code></pre>
<h3 id="udp-models"><a class="header" href="#udp-models">UDP models</a></h3>
<p>Some cells (typically muxes) use Verilog User-Defined Primitives with truth
tables. The parser (<code>parse_udp()</code>) converts these to a row-based representation,
which is then evaluated as sum-of-products during AIG decomposition.</p>
<h3 id="whats-loaded"><a class="header" href="#whats-loaded">What's loaded</a></h3>
<p>Only models for cell types actually present in the design are loaded. Sequential
cells are skipped (their behavior is hardcoded in the AIG builder). Tie cells
are also skipped (constant generation is trivial).</p>
<p><strong>For a new PDK</strong>: If the PDK uses the same Verilog gate primitive syntax, the
existing parsers should work. If it uses behavioral Verilog (<code>assign</code> statements,
<code>always</code> blocks), the parser would need extension.</p>
<h2 id="step-6-aig-decomposition"><a class="header" href="#step-6-aig-decomposition">Step 6: AIG Decomposition</a></h2>
<p><strong>Reference</strong>: <code>src/sky130_pdk.rs</code> -- <code>decompose_with_pdk()</code>,
<code>decompose_from_behavioral()</code></p>
<p>The decomposition converts each combinational cell to a set of 2-input AND gates
with optional inversions:</p>
<ol>
<li>Map the cell's input pin names to AIG pin indices via <code>CellInputs</code></li>
<li>Walk the behavioral model's gate list in topological order</li>
<li>For each gate, build the equivalent AIG sub-graph:
<ul>
<li><code>and</code>/<code>nand</code> -&gt; AND gate (with optional output inversion)</li>
<li><code>or</code>/<code>nor</code> -&gt; De Morgan's: <code>OR(a,b) = NOT(AND(NOT a, NOT b))</code></li>
<li><code>xor</code>/<code>xnor</code> -&gt; Four AND gates: <code>XOR(a,b) = NOT(AND(NOT(AND(a, NOT b)), NOT(AND(NOT a, b))))</code></li>
<li><code>buf</code>/<code>not</code> -&gt; Pass-through with optional inversion</li>
<li>UDP -&gt; Sum-of-products from truth table</li>
</ul>
</li>
<li>Record the output with cell origin (for SDF timing annotation)</li>
</ol>
<h3 id="cellinputs-struct"><a class="header" href="#cellinputs-struct">CellInputs struct</a></h3>
<p><code>CellInputs</code> has named fields for all possible input pins across all SKY130
cells (A, B, C, D, A_N, B_N, S, S0, S1, CIN, SET_B, RESET_B, etc.). The
<code>set_pin()</code> method maps netlist pin names to AIG pin indices.</p>
<p><strong>For a new PDK</strong>: If the PDK introduces pin names not in the current struct,
add new fields.</p>
<h2 id="step-7-aig-builder-integration"><a class="header" href="#step-7-aig-builder-integration">Step 7: AIG Builder Integration</a></h2>
<p><strong>Reference</strong>: <code>src/aig.rs</code> -- <code>get_sky130_dependencies()</code>, <code>sky130_preprocess()</code>,
<code>sky130_postprocess()</code></p>
<p>The AIG builder processes cells in three phases during topological traversal:</p>
<h3 id="dependencies-what-must-be-built-before-this-cell"><a class="header" href="#dependencies-what-must-be-built-before-this-cell">Dependencies (what must be built before this cell)</a></h3>
<ul>
<li><strong>Tie cells</strong>: No dependencies</li>
<li><strong>Sequential cells</strong>: Only SET_B and RESET_B pins (the data input D is handled
by the DFF mechanism, not combinational decomposition)</li>
<li><strong>Combinational cells</strong>: All input pins</li>
</ul>
<h3 id="preprocessing-before-dependencies-are-resolved"><a class="header" href="#preprocessing-before-dependencies-are-resolved">Preprocessing (before dependencies are resolved)</a></h3>
<ul>
<li><strong>Sequential cells</strong>: Create a DFF output AIG pin. This establishes the state
element before the combinational cone driving it is built.</li>
</ul>
<h3 id="postprocessing-after-all-dependencies-are-resolved"><a class="header" href="#postprocessing-after-all-dependencies-are-resolved">Postprocessing (after all dependencies are resolved)</a></h3>
<ul>
<li><strong>Tie cells</strong>: Wire <code>HI</code> to constant-1, <code>LO</code> to constant-0</li>
<li><strong>Sequential cells</strong>: Apply reset/set logic:
<code>Q = AND(OR(Q_state, NOT SET_B), RESET_B)</code> (active-low semantics)</li>
<li><strong>Combinational cells</strong>: Call <code>decompose_with_pdk()</code> and wire the resulting
AND gates into the AIG</li>
</ul>
<p><strong>For a new PDK</strong>: The three-phase structure is reusable. You need PDK-specific
implementations of each phase that handle the new cell types' pin names and
reset/set conventions.</p>
<h2 id="step-8-cli-integration"><a class="header" href="#step-8-cli-integration">Step 8: CLI Integration</a></h2>
<p><strong>Reference</strong>: <code>src/bin/loom.rs</code></p>
<p>The <code>cmd_map</code> function detects the library and creates the netlist with the
appropriate pin provider:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lib = detect_library_from_file(&amp;args.netlist_verilog)?;
let netlistdb = match lib {
    CellLibrary::SKY130 =&gt; NetlistDB::from_sverilog_file(&amp;paths, &amp;SKY130LeafPins),
    CellLibrary::AIGPDK =&gt; NetlistDB::from_sverilog_file(&amp;paths, &amp;AIGPDKLeafPins()),
    CellLibrary::Mixed =&gt; panic!("Mixed libraries not supported"),
};
<span class="boring">}</span></code></pre></pre>
<p><strong>For a new PDK</strong>: Add a match arm for the new library.</p>
<h2 id="testing-strategy"><a class="header" href="#testing-strategy">Testing Strategy</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h3>
<ol>
<li>
<p><strong>Cell type extraction</strong>: Verify prefix/suffix stripping</p>
</li>
<li>
<p><strong>Pin directions</strong>: Spot-check common cells</p>
</li>
<li>
<p><strong>Behavioral model parsing</strong>: Parse each cell type, verify gate count</p>
</li>
<li>
<p><strong>Decomposition correctness</strong>: For each combinational cell, exhaustively
test all input combinations against the PDK's truth table:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_all_cells_vs_pdk() {
    let pdk = load_test_pdk();
    for (cell_type, model) in &amp;pdk.models {
        // For each input combination:
        //   1. Evaluate behavioral model directly
        //   2. Decompose to AIG and evaluate AIG
        //   3. Assert outputs match
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This test exists in <code>src/sky130_pdk.rs</code> as <code>test_all_cells_vs_pdk</code> and
covers every combinational cell against every input combination.</p>
</li>
</ol>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h3>
<ol>
<li><strong>Small test circuit</strong>: Synthesize a simple design (DFF + some gates) to the
new PDK and verify simulation output matches a reference (e.g., iverilog)</li>
<li><strong>Flash boot test</strong>: If targeting an SoC, verify the CPU boots and reads from
flash (this exercises sequential logic, combinational cones, and IO)</li>
</ol>
<h2 id="file-checklist"><a class="header" href="#file-checklist">File Checklist</a></h2>
<p>For a complete PDK integration, you need:</p>
<div class="table-wrapper"><table><thead><tr><th>File</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>src/&lt;pdk&gt;.rs</code></td><td>LeafPinProvider, library detection, cell type extraction</td></tr>
<tr><td><code>src/&lt;pdk&gt;_pdk.rs</code></td><td>Cell classification, model parsing, AIG decomposition</td></tr>
<tr><td><code>src/aig.rs</code></td><td>AIG builder hooks (dependencies, pre/post-process)</td></tr>
<tr><td><code>src/sky130.rs</code></td><td>Update <code>CellLibrary</code> enum</td></tr>
<tr><td><code>src/bin/loom.rs</code></td><td>CLI match arms for new library</td></tr>
<tr><td><code>vendor/&lt;pdk&gt;/</code></td><td>PDK cell models (git submodule)</td></tr>
</tbody></table>
</div>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<ul>
<li>
<p><strong>Cell name collisions</strong>: Do not use prefix matching for cell classification.
<code>dlygate4sd3</code> starts with "dl" but is not a latch. Always derive the
exhaustive list from behavioral models.</p>
</li>
<li>
<p><strong>Active-low vs active-high resets</strong>: SKY130 uses active-low <code>RESET_B</code> and
<code>SET_B</code>. Other PDKs may use active-high. Get this wrong and every DFF will
be stuck.</p>
</li>
<li>
<p><strong>Multi-output cells</strong>: The AIG builder processes one output pin at a time.
If a cell has both Q and Q_N outputs (e.g., <code>dfbbp</code>), the second output
must be derived from the first (Q_N = NOT Q), not decomposed independently.</p>
</li>
<li>
<p><strong>Liberty file size</strong>: SKY130's liberty files are 12MB+. If your PDK has
similarly large files, ensure the parser doesn't OOM or timeout.</p>
</li>
<li>
<p><strong>Power/ground pins</strong>: Post-layout netlists often include VPWR/VGND pins.
Use the unpowered netlist variant (<code>.nl.v</code> not <code>.pnl.v</code> in OpenLane2) or
handle power pins as constants in the pin provider.</p>
</li>
<li>
<p><strong>Hold-time repair buffers</strong>: P&amp;R tools insert delay buffers (like
<code>dlygate4sd3</code>) that must be treated as combinational. If your PDK's delay
cells have names that collide with sequential cell prefixes, the whitelist
approach prevents misclassification.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="timing-violations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="troubleshooting-vcd.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="timing-violations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="troubleshooting-vcd.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
