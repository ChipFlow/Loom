<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Loom Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Loom Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ChipFlow/Loom" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="loom-documentation"><a class="header" href="#loom-documentation">Loom Documentation</a></h1>
<p>Welcome to the documentation for Loom, a GPU-accelerated RTL logic simulator.</p>
<p>Use the sidebar to navigate between topics, or start with the <a href="usage.html">Getting Started</a> guide.</p>
<h2 id="documents"><a class="header" href="#documents">Documents</a></h2>
<h3 id="core-documentation"><a class="header" href="#core-documentation">Core Documentation</a></h3>
<ul>
<li>
<p><strong><a href="simulation-architecture.html">Simulation Architecture</a></strong>: Detailed explanation of Loom's internal architecture</p>
<ul>
<li>Pipeline stages (NetlistDB → AIG → StagedAIG → Partitions → FlattenedScript → GPU)</li>
<li>Data structures and representations</li>
<li>VCD input/output format requirements</li>
<li>Assertion and display support infrastructure</li>
<li>Performance characteristics</li>
<li>Known issues and limitations</li>
</ul>
</li>
<li>
<p><strong><a href="timing-simulation.html">Timing Simulation</a></strong>: CPU-based timing simulation with Liberty/SDF delays</p>
</li>
<li>
<p><strong><a href="timing-violations.html">Timing Violations</a></strong>: GPU-side setup/hold violation detection</p>
</li>
</ul>
<h3 id="troubleshooting-guides"><a class="header" href="#troubleshooting-guides">Troubleshooting Guides</a></h3>
<ul>
<li><strong><a href="troubleshooting-vcd.html">Troubleshooting VCD</a></strong>: Debugging VCD input issues
<ul>
<li>VCD hierarchy requirements</li>
<li>Signal naming and matching</li>
<li>Solutions for flat VCD generation</li>
<li>Diagnostic checklist</li>
<li>Working examples</li>
</ul>
</li>
</ul>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<h3 id="vcd-input-requirements-critical"><a class="header" href="#vcd-input-requirements-critical">VCD Input Requirements (Critical!)</a></h3>
<p>Loom expects VCD signals at <strong>absolute top-level</strong> (no module hierarchy):</p>
<pre><code class="language-verilog">// ✓ Correct testbench
initial begin
    $dumpfile("output.vcd");
    $dumpvars(1, clk, reset, din, dout);  // Depth 1, explicit signals
end

// ✗ Incorrect testbench
initial begin
    $dumpfile("output.vcd");
    $dumpvars(0, testbench);  // Dumps entire hierarchy
end
</code></pre>
<h3 id="debug-commands"><a class="header" href="#debug-commands">Debug Commands</a></h3>
<pre><code class="language-bash"># Enable debug logging
RUST_LOG=debug cargo run -r --features metal --bin loom -- sim &lt;args&gt;

# Verify with CPU simulation
cargo run -r --features metal --bin loom -- sim &lt;args&gt; --check-with-cpu

# Check VCD structure
grep '\$scope\|\$var' input.vcd | head -20
</code></pre>
<h3 id="key-statistics"><a class="header" href="#key-statistics">Key Statistics</a></h3>
<p>When running Loom, look for these diagnostic outputs:</p>
<pre><code>netlist has X pins, Y aig pins, Z and gates        # AIG complexity
current: N endpoints, try M parts                  # Partition count
Built script for B blocks, reg/io state size S     # Final script
WARN (GATESIM_VCDI_MISSING_PI) ...                 # VCD issues!
</code></pre>
<h2 id="investigation-methodology"><a class="header" href="#investigation-methodology">Investigation Methodology</a></h2>
<p>This documentation was created through systematic investigation of Loom's behavior:</p>
<ol>
<li><strong>Source Code Analysis</strong>: Examined <code>src/aig.rs</code>, <code>src/flatten.rs</code>, <code>src/staging.rs</code></li>
<li><strong>Debug Tracing</strong>: Used <code>RUST_LOG=debug</code> to capture internal state</li>
<li><strong>Test Case Development</strong>: Created minimal reproducible examples</li>
<li><strong>Comparative Testing</strong>: Compared Loom vs iverilog outputs</li>
<li><strong>Third-Party Validation</strong>: Tested with real-world examples (sva-playground)</li>
</ol>
<h2 id="known-issues-documented"><a class="header" href="#known-issues-documented">Known Issues Documented</a></h2>
<ol>
<li>
<p><strong>VCD Hierarchy Mismatch</strong> (CRITICAL):</p>
<ul>
<li>Loom expects flat VCD hierarchy</li>
<li>Most testbenches generate hierarchical VCDs</li>
<li>See troubleshooting-vcd.md for solutions</li>
</ul>
</li>
<li>
<p><strong>Complex FSM Simulation</strong>:</p>
<ul>
<li>Some FSM designs don't simulate correctly</li>
<li>Under investigation (safe.v example in third_party tests)</li>
<li>May be related to synthesis optimization or reset handling</li>
</ul>
</li>
<li>
<p><strong>Format String Preservation</strong>:</p>
<ul>
<li>Yosys may not preserve format attributes</li>
<li>Display messages show placeholders</li>
<li>Extract format strings from pre-synthesis JSON as workaround</li>
</ul>
</li>
</ol>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>When adding documentation:</p>
<ol>
<li><strong>Be specific</strong>: Include actual commands, file paths, code snippets</li>
<li><strong>Show examples</strong>: Both working and non-working cases</li>
<li><strong>Link related docs</strong>: Cross-reference other documentation files</li>
<li><strong>Date updates</strong>: Update version and date at bottom of documents</li>
<li><strong>Test instructions</strong>: Verify all commands actually work</li>
</ol>
<h2 id="future-documentation-needs"><a class="header" href="#future-documentation-needs">Future Documentation Needs</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Performance tuning guide (optimal <code>NUM_BLOCKS</code>, <code>--level-split</code>)</li>
<li><input disabled="" type="checkbox"/>
Memory (SRAM) modeling and synthesis</li>
<li><input disabled="" type="checkbox"/>
Custom cell library support beyond AIGPDK</li>
<li><input disabled="" type="checkbox"/>
Multi-clock domain handling</li>
<li><input disabled="" type="checkbox"/>
VCD scope option detailed behavior</li>
<li><input disabled="" type="checkbox"/>
GPU kernel optimization internals</li>
<li><input disabled="" type="checkbox"/>
Comparison with other simulators (VCS, Verilator, iverilog)</li>
</ul>
<h2 id="related-resources"><a class="header" href="#related-resources">Related Resources</a></h2>
<ul>
<li><strong>Main README</strong>: <code>../README.md</code> - Project overview and quick start</li>
<li><strong>CLAUDE.md</strong>: <code>../CLAUDE.md</code> - Development guidelines and architecture overview</li>
<li><strong>Test Suite</strong>: <code>../tests/</code> - Examples and regression tests</li>
<li><strong>Third-Party Tests</strong>: <code>../tests/regression/third_party/</code> - Real-world examples with attribution</li>
</ul>
<hr />
<p><strong>Last Updated</strong>: 2026-02-16
<strong>Maintained By</strong>: ChipFlow + Community Contributions</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-loom"><a class="header" href="#getting-started-with-loom">Getting Started with Loom</a></h1>
<p><strong>Caveats</strong>: Loom currently only supports non-interactive testbenches. This means the input to the circuit needs to be a static waveform (e.g., VCD). Registers and clock gates inside the circuit are allowed, but latches and other asynchronous sequential logics are currently unsupported.</p>
<p><strong>Dataset</strong>: Some (namely, netlists after AIG transformation in Steps 1-2 below, and reference VCDs) input data is available <a href="https://drive.google.com/drive/folders/1M42vFoVZhG4ZjyD1hqYD0Hrw8F1rwNXd?usp=drive_link">here</a> .</p>
<h2 id="step-0-download-the-aig-process-kit"><a class="header" href="#step-0-download-the-aig-process-kit">Step 0. Download the AIG Process Kit</a></h2>
<p>Go to <a href="./aigpdk">aigpdk</a> directory where you can download <code>aigpdk.lib</code>, <code>aigpdk_nomem.lib</code>, <code>aigpdk.v</code>, and <code>memlib_yosys.txt</code>. You will need them later in the flow.</p>
<p>Before continuing, make sure your design contains only synchronous logic.
If your design has clock gates implemented in your RTL code, you need to replace them manually with instantiations to the <code>CKLNQD</code> module in <code>aigpdk.v</code>.
Also, you are advised to be familiar with where memory blocks (e.g., caches) are implemented in your design so you can check that the memory blocks are mapped correctly later.</p>
<h2 id="step-1-memory-synthesis-with-yosys"><a class="header" href="#step-1-memory-synthesis-with-yosys">Step 1. Memory Synthesis with Yosys</a></h2>
<p>This step makes use of the open-source <a href="https://github.com/YosysHQ/yosys">Yosys</a> synthesizer to recognize and map the memory blocks automatically.</p>
<p>Download and compile the latest version of Yosys. Then run yosys shell with the following synthesis script.</p>
<pre><code class="language-tcl"># replace this with paths to your RTL code, and add `-I`, `-D`, `-sv` etc when necessary
read_verilog xx.v yy.v top.v

# replace TOP_MODULE with your top module name
hierarchy -check -top TOP_MODULE

# simplify design before mapping
proc;;
opt_expr; opt_dff; opt_clean
memory -nomap

# map the rams
# point -lib path to your downloaded memlib_yosys.txt
memory_libmap -lib path/to/memlib_yosys.txt -logic-cost-rom 100 -logic-cost-ram 100
</code></pre>
<p>The <code>memory_libmap</code> command will output a list of RAMs it found and mapped.</p>
<ul>
<li>If you see <code>$__RAMGEM_SYNC_</code> (naming inherited from GEM), it means the mapping is successful.</li>
<li>If you see <code>$__RAMGEM_ASYNC_</code>, it means this RAM is found to have asynchronous READ port. You need to confirm if it is the case.
<ul>
<li>If it is a synchronous one but accidentally recognized as asynchronous, you might need to patch the RTL code to fix it. There might be multiple reasons it cannot be recognized as synchronous. For example, <a href="https://github.com/YosysHQ/yosys/issues/4521">when the read and write clocks are different</a>.</li>
<li>If it is indeed asynchronous, check its size. If its size is very small and affordable to be synthesized using registers and mux trees (which is <em>very</em> expensive for large RAM banks), you can remove the <code>$__RAMGEM_ASYNC_</code> block in <code>memlib_yosys.txt</code>, re-run Yosys to force the use of registers.</li>
</ul>
</li>
<li>If you see <code>using FF mapping for memory</code>, it means the memory is recognized, but due to it being nonstandard (e.g., special global reset or nontrivial initialization), Loom will fall back to registers and mux trees. If the size of the memory is small, this is usually not an issue. Otherwise, you are advised to try other implementations.</li>
</ul>
<p>After a successful mapping, use the following command to write out the mapped RTL as a single Verilog file.</p>
<pre><code class="language-tcl">write_verilog memory_mapped.v
</code></pre>
<p>Check the correctness of this step by simulating <code>memory_mapped.v</code> with your reference CPU simulator.</p>
<h2 id="step-2-logic-synthesis"><a class="header" href="#step-2-logic-synthesis">Step 2. Logic Synthesis</a></h2>
<p>This step maps all combinational and sequential logic into a special set of standard cells we defined in <code>aigpdk.lib</code>.
The quality of synthesis is directly tied to Loom's final performance, so we suggest you use a commercial synthesis tool like DC. You can also use Yosys to complete this if you do not have access to a commercial synthesis tool.</p>
<p>Check the correctness of this step by simulating <code>gatelevel.gv</code> with your reference CPU simulator.</p>
<h3 id="use-synopsys-dc"><a class="header" href="#use-synopsys-dc">Use Synopsys DC</a></h3>
<p>First, you need to compile <code>aigpdk.lib</code> to <code>aigpdk.db</code> using Library Compiler.</p>
<p>With that, you synthesize the <code>memory_mapped.v</code> obtained before under <code>aigpdk.db</code>.</p>
<p>Some key commands you may use on top of your existing DC flow:</p>
<pre><code class="language-tcl"># change path/to/aigpdk.db to a correct path. same for other commands.
set_app_var link_path path/to/aigpdk.db
set_app_var target_library path/to/aigpdk.db
read_file -format db $target_library

# elaborate TOP_MODULE
# current_design TOP_MODULE

# timing settings like create_clock ... are recommended. Loom benefits from timing-driven synthesis.

compile_ultra -no_seq_output_inversion -no_autoungroup
optimize_netlist -area

write -format verilog -hierarchy -out gatelevel.gv
</code></pre>
<h3 id="use-yosys-example-script"><a class="header" href="#use-yosys-example-script">Use Yosys: Example script</a></h3>
<pre><code class="language-tcl"># if you exited Yosys in step 2, you can read back in your memory_mapped.v yourself.
# read_verilog memory_mapped.v
# hierarchy -check -top TOP_MODULE

# synthesis
synth -flatten
delete t:$print

# change path/to/aigpdk_nomem.lib to a correct path. same for other commands.
dfflibmap -liberty path/to/aigpdk_nomem.lib
opt_clean -purge
abc -liberty path/to/aigpdk_nomem.lib
opt_clean -purge
techmap
abc -liberty path/to/aigpdk_nomem.lib
opt_clean -purge

# write out
write_verilog gatelevel.gv
</code></pre>
<h2 id="step-3-download-and-compile-loom"><a class="header" href="#step-3-download-and-compile-loom">Step 3. Download and Compile Loom</a></h2>
<p>Download and install the Rust toolchain. This is as simple as a one-liner in your terminal. We recommend <a href="https://rustup.rs/">https://rustup.rs</a>.</p>
<p>Clone Loom along with its dependencies.</p>
<pre><code class="language-sh">git clone https://github.com/ChipFlow/Loom.git
cd Loom
git submodule update --init --recursive
</code></pre>
<p>Loom supports two GPU backends: <strong>CUDA</strong> (NVIDIA GPUs on Linux) and <strong>Metal</strong> (Apple Silicon Macs).</p>
<p>All functionality is accessed through the <code>loom</code> CLI, which provides <code>map</code>, <code>sim</code>, and <code>cosim</code> subcommands:</p>
<pre><code class="language-sh"># Mapping (no GPU features needed)
cargo run -r --bin loom -- map --help

# Simulation (Metal - macOS)
cargo run -r --features metal --bin loom -- sim --help

# Simulation (CUDA - Linux, requires CUDA toolkit)
cargo run -r --features cuda --bin loom -- sim --help
</code></pre>
<h2 id="map-the-design-with-loom"><a class="header" href="#map-the-design-with-loom">Map the Design with Loom</a></h2>
<p>Loom compiles and links to <a href="https://github.com/gzz2000/mt-kahypar-sc">mt-kahypar-sc</a> for hypergraph partitioning automatically.</p>
<p>Run the following command to start the Boolean processor mapping.</p>
<pre><code class="language-sh">cargo run -r --bin loom -- map path/to/gatelevel.gv path/to/result.gemparts
</code></pre>
<p>The mapped result will be stored in a binary file <code>result.gemparts</code>.</p>
<p>If the mapping failed due to failure to partition deep circuits (which often shows as trying to partition a circuit with only 0 or 1 endpoints), try adding a <code>--level-split</code> option to force a stage split. For example <code>--level-split 30</code> or <code>--level-split 20,40</code>. If you used this, remember to add the same <code>--level-split</code> option when you simulate.</p>
<h2 id="simulate-the-design"><a class="header" href="#simulate-the-design">Simulate the Design</a></h2>
<h3 id="metal-macos"><a class="header" href="#metal-macos">Metal (macOS)</a></h3>
<p>Use <code>NUM_BLOCKS=1</code> for Metal.</p>
<pre><code class="language-sh">cargo run -r --features metal --bin loom -- sim path/to/gatelevel.gv path/to/result.gemparts path/to/input.vcd path/to/output.vcd 1
</code></pre>
<h3 id="cuda-linux"><a class="header" href="#cuda-linux">CUDA (Linux)</a></h3>
<p>Replace <code>NUM_BLOCKS</code> with twice the number of physical streaming multiprocessors (SMs) of your GPU.</p>
<pre><code class="language-sh">cargo run -r --features cuda --bin loom -- sim path/to/gatelevel.gv path/to/result.gemparts path/to/input.vcd path/to/output.vcd NUM_BLOCKS
</code></pre>
<h3 id="vcd-scope-handling"><a class="header" href="#vcd-scope-handling">VCD Scope Handling</a></h3>
<p>Loom automatically detects the correct VCD scope containing your design's ports. In most cases, you don't need to specify <code>--input-vcd-scope</code>. If auto-detection fails or you need to override it, use:</p>
<pre><code class="language-sh"># Metal
cargo run -r --features metal --bin loom -- sim path/to/gatelevel.gv path/to/result.gemparts path/to/input.vcd path/to/output.vcd 1 --input-vcd-scope "testbench/dut"

# CUDA
cargo run -r --features cuda --bin loom -- sim path/to/gatelevel.gv path/to/result.gemparts path/to/input.vcd path/to/output.vcd NUM_BLOCKS --input-vcd-scope "testbench/dut"
</code></pre>
<p>Use slash separators (<code>/</code>) for hierarchical paths, not dots. See <a href="troubleshooting-vcd.html">troubleshooting-vcd.md</a> for details.</p>
<p>The simulated output ports value will be stored in <code>output.vcd</code>.</p>
<p><strong>Caveat</strong>: The actual GPU simulation runtime will also be outputted. You might see a long time before GPU enters due to reading and parsing <code>input.vcd</code>. You are recommended to develop your own pipeline to feed the input waveform into Loom's GPU kernels.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gem-simulation-architecture"><a class="header" href="#gem-simulation-architecture">GEM Simulation Architecture</a></h1>
<p>This document describes GEM's internal simulation architecture based on investigation and testing.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>GEM (GPU-accelerated Emulator-inspired RTL simulation) compiles gate-level netlists into GPU kernels that simulate designs 5-40X faster than CPU-based simulators. It works like an FPGA-based RTL emulator by converting designs into an and-inverter graph (AIG), partitioning it for GPU blocks, and generating optimized GPU code.</p>
<h2 id="pipeline-stages"><a class="header" href="#pipeline-stages">Pipeline Stages</a></h2>
<pre><code>Verilog Netlist → NetlistDB → AIG → StagedAIG → Partitions → FlattenedScript → GPU Kernel
                     ↓            ↓                    ↓            ↓
                  Parse      Synthesis         Hypergraph     Instruction
                  Netlist    to AIGs          Partitioning    Generation
</code></pre>
<h3 id="1-netlistdb-input-parsing"><a class="header" href="#1-netlistdb-input-parsing">1. NetlistDB (Input Parsing)</a></h3>
<p><strong>Input</strong>: Gate-level Verilog (<code>.gv</code> files) from synthesis tools (Yosys, Design Compiler)</p>
<p><strong>Process</strong>:</p>
<ul>
<li>Parses structural Verilog using <code>sverilogparse</code> crate</li>
<li>Creates flattened netlist database with cells, pins, nets</li>
<li>Identifies primary inputs, outputs, clock signals</li>
<li>Stores connectivity in CSR (Compressed Sparse Row) format</li>
</ul>
<p><strong>Key Limitations</strong>:</p>
<ul>
<li>Only supports synthesized gate-level netlists (not RTL)</li>
<li>No behavioral Verilog constructs (always blocks, if/case statements)</li>
<li>Expects standard cells from supported libraries (AIGPDK)</li>
</ul>
<h3 id="2-aig-and-inverter-graph"><a class="header" href="#2-aig-and-inverter-graph">2. AIG (And-Inverter Graph)</a></h3>
<p><strong>Process</strong>: Converts gate-level netlist to AIG representation</p>
<p><strong>Data Structure</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DriverType {
    AndGate,           // Basic AND gate
    DFF,               // D flip-flop
    ClockGate,         // Clock gating cell
    RAMBlock,          // Memory block
    GemAssert,         // Assertion checking
    GemDisplay,        // Display output
    // ... more types
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Statistics</strong> (example from safe.v):</p>
<ul>
<li><strong>157 AIG pins</strong>: Internal circuit nodes</li>
<li><strong>133 AND gates</strong>: Logic operations</li>
<li><strong>16 DFF cells</strong>: Sequential elements</li>
<li><strong>2 GEM_ASSERT cells</strong>: Assertion nodes</li>
<li><strong>480 total pins</strong>: Including I/O</li>
</ul>
<p><strong>Key Features</strong>:</p>
<ul>
<li>Clock inference from DFF connections</li>
<li>Assertion cell detection (<code>GEM_ASSERT</code>, <code>GEM_DISPLAY</code>)</li>
<li>Endpoint grouping for outputs and registers</li>
</ul>
<h3 id="3-stagedaig-pipeline-staging"><a class="header" href="#3-stagedaig-pipeline-staging">3. StagedAIG (Pipeline Staging)</a></h3>
<p><strong>Purpose</strong>: Split deep combinational logic into pipeline stages</p>
<p><strong>Process</strong>:</p>
<ul>
<li>Analyzes combinational depth between registers</li>
<li>Splits logic at <code>--level-split</code> thresholds</li>
<li>Creates pipeline stages to fit GPU resource constraints</li>
</ul>
<p><strong>When Needed</strong>:</p>
<ul>
<li>Designs with very deep combinational paths (&gt;50 levels)</li>
<li>When single-stage partitioning fails resource limits</li>
<li>Use <code>--level-split 30</code> or <code>--level-split 20,40</code> to force splits</li>
</ul>
<h3 id="4-partitioning-hypergraph-cut"><a class="header" href="#4-partitioning-hypergraph-cut">4. Partitioning (Hypergraph Cut)</a></h3>
<p><strong>Tool</strong>: mt-kahypar hypergraph partitioner</p>
<p><strong>Constraints</strong> (GPU block resources):</p>
<ul>
<li>Max 8191 unique inputs per partition</li>
<li>Max 8191 unique outputs per partition</li>
<li>Max 4095 intermediate pins alive per stage</li>
<li>Max 64 SRAM output groups</li>
</ul>
<p><strong>Process</strong>:</p>
<ul>
<li>Interactive partitioning (<code>loom map</code>)</li>
<li>Tries 1 partition first, then increases if needed</li>
<li>Merges partitions to minimize inter-partition communication</li>
</ul>
<p><strong>Output</strong>: <code>.gemparts</code> file with partition assignments</p>
<h3 id="5-flattenedscript-gpu-instruction-generation"><a class="header" href="#5-flattenedscript-gpu-instruction-generation">5. FlattenedScript (GPU Instruction Generation)</a></h3>
<p><strong>Process</strong>: Generates GPU execution script from partitions</p>
<p><strong>Script Components</strong>:</p>
<ul>
<li><strong>Boomerang stages</strong>: Hierarchical 8192→1 reduction structure</li>
<li><strong>State buffer</strong>: Packed 32-bit words for all register values</li>
<li><strong>SRAM interface</strong>: Memory block read/write operations</li>
<li><strong>Assertion positions</strong>: Bit positions for assertion conditions</li>
<li><strong>Display positions</strong>: Enable bits and argument positions</li>
</ul>
<p><strong>Statistics</strong> (example):</p>
<pre><code>reg/io state size: 133 bits → 5 words (32-bit)
script size: 30208 instructions
assertion_positions: [(cell_id, bit_pos, msg_id, type)]
display_positions: [(cell_id, enable_pos, format, arg_positions, widths)]
</code></pre>
<p><strong>Key Insight</strong>: All state is packed into a flat bit array, indexed by position in 32-bit words.</p>
<h3 id="6-gpu-kernel-execution"><a class="header" href="#6-gpu-kernel-execution">6. GPU Kernel Execution</a></h3>
<p><strong>Kernel Types</strong>:</p>
<ul>
<li><code>kernel_v1.cu</code> / <code>kernel_v1_impl.cuh</code>: CUDA implementation</li>
<li><code>kernel_v1.metal</code>: Metal (Apple Silicon) implementation</li>
</ul>
<p><strong>Execution Model</strong>:</p>
<ul>
<li>Each GPU block simulates one partition</li>
<li>Multiple blocks run in parallel</li>
<li>State synchronized between stages</li>
<li>CPU checks assertion/display conditions after GPU completes</li>
</ul>
<h2 id="vcd-inputoutput"><a class="header" href="#vcd-inputoutput">VCD Input/Output</a></h2>
<h3 id="input-vcd-requirements"><a class="header" href="#input-vcd-requirements">Input VCD Requirements</a></h3>
<p><strong>Critical Discovery</strong>: GEM expects VCD signals at <strong>absolute top-level</strong> (no module hierarchy).</p>
<p><strong>Expected Signal Format</strong>:</p>
<pre><code class="language-vcd">$var reg 1 ! clk $end
$var reg 1 " reset $end
$var reg 4 # din [3:0] $end
$var reg 1 $ din_valid $end
</code></pre>
<p><strong>NOT</strong> (with module scope):</p>
<pre><code class="language-vcd">$scope module testbench $end
  $scope module dut $end
    $var wire 1 ! clk $end
    ...
</code></pre>
<p><strong>Signal Matching</strong>:</p>
<ul>
<li>GEM looks for signals matching synthesized module port names</li>
<li>Uses <code>HierName()</code> (empty hierarchy) for matching</li>
<li>If signals are scoped under modules, GEM reports:
<pre><code>WARN (GATESIM_VCDI_MISSING_PI) Primary input port (HierName(), "reset", None) not present in the VCD input
</code></pre>
</li>
</ul>
<p><strong>VCD Scope Option</strong>:</p>
<ul>
<li><code>--input-vcd-scope &lt;scope&gt;</code>: Specify module hierarchy to read from</li>
<li><strong>Current Issue</strong>: Even with scope specified, signal matching fails</li>
<li><strong>Workaround</strong>: Generate VCD with signals at absolute top level</li>
</ul>
<h3 id="output-vcd-structure"><a class="header" href="#output-vcd-structure">Output VCD Structure</a></h3>
<p>GEM generates minimal VCD with only primary outputs:</p>
<pre><code class="language-vcd">$timescale 1 ns $end
$scope module gem_top_module $end
$var wire 1 ! unlocked $end
$upscope $end
</code></pre>
<p>Internal states and intermediate signals are not dumped.</p>
<h2 id="assertion-and-display-support"><a class="header" href="#assertion-and-display-support">Assertion and Display Support</a></h2>
<h3 id="assertion-infrastructure"><a class="header" href="#assertion-infrastructure">Assertion Infrastructure</a></h3>
<p><strong>Synthesis Flow</strong>:</p>
<pre><code>Verilog assert() → Yosys $check cell → techmap gem_formal.v → GEM_ASSERT cell
</code></pre>
<p><strong>Runtime</strong>:</p>
<ul>
<li>GEM stores assertion positions in <code>FlattenedScript</code></li>
<li>CPU checks assertion bits after GPU simulation</li>
<li>Configurable actions: Log, Pause, Terminate</li>
</ul>
<p><strong>AssertConfig</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AssertConfig {
    pub on_failure: AssertAction,  // Log, Pause, Terminate
    pub max_failures: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="display-infrastructure"><a class="header" href="#display-infrastructure">Display Infrastructure</a></h3>
<p><strong>Synthesis Flow</strong>:</p>
<pre><code>Verilog $display() → Yosys $print cell → techmap gem_formal.v → GEM_DISPLAY cell
</code></pre>
<p><strong>Runtime</strong>:</p>
<ul>
<li>Format strings stored in JSON metadata</li>
<li>CPU checks display enable bits after GPU simulation</li>
<li>Arguments extracted from state buffer positions</li>
</ul>
<p><strong>Limitation</strong>: Format string preservation depends on Yosys synthesis preserving attributes.</p>
<h2 id="debug-information"><a class="header" href="#debug-information">Debug Information</a></h2>
<h3 id="enabling-debug-output"><a class="header" href="#enabling-debug-output">Enabling Debug Output</a></h3>
<pre><code class="language-bash"># Metal simulation with debug logging
RUST_LOG=debug cargo run -r --features metal --bin loom -- sim &lt;args&gt;

# CPU verification (slower but validates GPU results)
cargo run -r --features metal --bin loom -- sim &lt;args&gt; --check-with-cpu
</code></pre>
<h3 id="key-debug-messages"><a class="header" href="#key-debug-messages">Key Debug Messages</a></h3>
<p><strong>AIG Construction</strong>:</p>
<pre><code>Found GEM_ASSERT cell 143 (condition_iv=0, en_iv=0, a_iv=76, clken_iv=2)
Found GEM_DISPLAY cell 24 (enable_iv=2, clken_iv=2, args=32)
</code></pre>
<p><strong>Partitioning</strong>:</p>
<pre><code>netlist has 480 pins, 157 aig pins, 133 and gates
current: 19 endpoints, try 1 parts
after merging: 1 parts
</code></pre>
<p><strong>Flattening</strong>:</p>
<pre><code>Built script for 48 blocks, reg/io state size 133, sram size 0, script size 30208
Assertion: cell=144, pos=4195 (word=131, bit=3), msg_id=144, type=None
Display: cell=24, enable_pos=5154 (word=161, bit=2), format='...', args=[...]
</code></pre>
<p><strong>VCD Reading</strong>:</p>
<pre><code>WARN (GATESIM_VCDI_MISSING_PI) Primary input port (HierName(), "reset", None) not present
</code></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="speedup-vs-cpu"><a class="header" href="#speedup-vs-cpu">Speedup vs CPU</a></h3>
<ul>
<li>Simple designs: 5-10X faster</li>
<li>Complex designs: 10-40X faster</li>
<li>Depends on:
<ul>
<li>Number of GPU SMs (streaming multiprocessors)</li>
<li>Partition granularity</li>
<li>VCD I/O overhead</li>
</ul>
</li>
</ul>
<h3 id="resource-scaling"><a class="header" href="#resource-scaling">Resource Scaling</a></h3>
<p><strong>GPU Block Count</strong>: Set <code>NUM_BLOCKS</code> to 2× number of GPU SMs</p>
<ul>
<li>Apple M4 Pro: 48 blocks (24 SMs × 2)</li>
<li>NVIDIA GPUs: Check SM count with <code>nvidia-smi</code></li>
</ul>
<p><strong>Memory Usage</strong>:</p>
<ul>
<li>State buffer: <code>num_blocks × state_size × num_cycles × 4 bytes</code></li>
<li>Script: <code>script_size × 4 bytes</code> (shared across blocks)</li>
</ul>
<h2 id="known-issues-and-limitations"><a class="header" href="#known-issues-and-limitations">Known Issues and Limitations</a></h2>
<h3 id="1-vcd-hierarchy-mismatch"><a class="header" href="#1-vcd-hierarchy-mismatch">1. VCD Hierarchy Mismatch</a></h3>
<p><strong>Issue</strong>: GEM expects flat VCD signal hierarchy
<strong>Impact</strong>: Missing input signals cause incorrect simulation results
<strong>Workaround</strong>: Generate VCD with <code>$dumpvars(1, sig1, sig2, ...)</code> at top level
<strong>Status</strong>: Under investigation</p>
<h3 id="2-complex-fsm-designs"><a class="header" href="#2-complex-fsm-designs">2. Complex FSM Designs</a></h3>
<p><strong>Issue</strong>: Some FSM designs don't simulate correctly even with proper VCD
<strong>Example</strong>: safe.v (9-state PIN cracker FSM)
<strong>Possible Causes</strong>:</p>
<ul>
<li>Synthesis optimization changes FSM encoding</li>
<li>Initial state handling differences</li>
<li>Reset timing issues
<strong>Status</strong>: Identified through third-party test suite</li>
</ul>
<h3 id="3-format-string-preservation"><a class="header" href="#3-format-string-preservation">3. Format String Preservation</a></h3>
<p><strong>Issue</strong>: Yosys synthesis may not preserve <code>gem_format</code> attributes
<strong>Impact</strong>: Display messages show placeholders instead of actual format strings
<strong>Workaround</strong>: Extract format strings from pre-synthesis JSON
<strong>Status</strong>: Tool limitation, not GEM bug</p>
<h2 id="investigation-methodology-1"><a class="header" href="#investigation-methodology-1">Investigation Methodology</a></h2>
<p>This documentation was created through systematic investigation:</p>
<ol>
<li><strong>Structure Analysis</strong>: Examined source code in <code>src/aig.rs</code>, <code>src/flatten.rs</code>, <code>src/staging.rs</code></li>
<li><strong>Debug Tracing</strong>: Used <code>RUST_LOG=debug</code> to capture internal state</li>
<li><strong>Netlist Inspection</strong>: Analyzed synthesized <code>.gv</code> files with <code>grep</code></li>
<li><strong>VCD Comparison</strong>: Compared iverilog vs GEM VCD outputs</li>
<li><strong>Test Case Development</strong>: Created minimal reproducible examples</li>
<li><strong>Iterative Debugging</strong>: Progressively simplified designs to isolate issues</li>
</ol>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>Main codebase: <code>src/</code> directory</li>
<li>EDA infrastructure: <code>vendor/eda-infra-rs/</code> submodule (netlistdb, vcd-ng, ulib)</li>
<li>AIGPDK library: <code>aigpdk/</code> directory</li>
<li>Test cases: <code>tests/</code> directory</li>
<li>Third-party examples: <code>tests/regression/third_party/</code></li>
</ul>
<hr />
<p><strong>Document Version</strong>: 1.0
<strong>Last Updated</strong>: 2025-01-08
<strong>Authors</strong>: NVIDIA GEM Team + Claude Code Investigation</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timing-simulation-in-gem"><a class="header" href="#timing-simulation-in-gem">Timing Simulation in GEM</a></h1>
<p>This document explains GEM's boomerang evaluation architecture and how timing simulation with per-gate delays can be implemented efficiently on GPU.</p>
<h2 id="background-the-simulation-challenge"><a class="header" href="#background-the-simulation-challenge">Background: The Simulation Challenge</a></h2>
<p>GEM simulates And-Inverter Graphs (AIGs) where every node is either:</p>
<ul>
<li>A <strong>primary input</strong> (value comes from VCD stimulus)</li>
<li>An <strong>AND gate</strong> with two inputs (possibly inverted)</li>
</ul>
<p>Traditional simulation evaluates gates in topological order, which is inherently serial. GPUs excel at massive parallelism - thousands of threads doing the same operation on different data. GEM bridges this gap with the <strong>boomerang</strong> architecture.</p>
<h2 id="boomerang-evaluation"><a class="header" href="#boomerang-evaluation">Boomerang Evaluation</a></h2>
<h3 id="core-concept"><a class="header" href="#core-concept">Core Concept</a></h3>
<p>The boomerang structure is a <strong>hierarchical reduction tree</strong> that maps an AIG onto GPU threads. It's called "boomerang" because data flows down the tree during reduction, then results are written back out at various levels - like a boomerang going out and returning.</p>
<h3 id="hierarchy-structure"><a class="header" href="#hierarchy-structure">Hierarchy Structure</a></h3>
<p>GEM uses <code>BOOMERANG_NUM_STAGES = 13</code>, meaning the tree has 2^13 = 8192 leaf positions:</p>
<pre><code>Level 0 (inputs):   8192 positions
Level 1:            4096 positions  (8192 / 2)
Level 2:            2048 positions
Level 3:            1024 positions
Level 4:             512 positions
Level 5:             256 positions
Level 6:             128 positions
Level 7:              64 positions
Level 8:              32 positions
Level 9:              16 positions
Level 10:              8 positions
Level 11:              4 positions
Level 12:              2 positions
Level 13 (output):     1 position
</code></pre>
<p>Each level halves the number of positions by computing AND gates that combine pairs.</p>
<h3 id="thread-organization"><a class="header" href="#thread-organization">Thread Organization</a></h3>
<p>A GPU block has <strong>256 threads</strong> (<code>threadIdx.x</code> = 0..255). Each thread holds a <strong>32-bit word</strong> where each bit represents an independent Boolean signal:</p>
<pre><code>Thread 0:   [bit0, bit1, bit2, ... bit31]  = 32 Boolean signals
Thread 1:   [bit0, bit1, bit2, ... bit31]  = 32 Boolean signals
...
Thread 255: [bit0, bit1, bit2, ... bit31]  = 32 Boolean signals
            ─────────────────────────────
            Total: 256 × 32 = 8192 signals per level
</code></pre>
<p><strong>Thread position</strong> refers to <code>threadIdx.x</code> - which of the 256 threads we're addressing. Each thread position processes 32 signals in parallel using SIMD operations.</p>
<h3 id="memory-layout"><a class="header" href="#memory-layout">Memory Layout</a></h3>
<pre><code class="language-cpp">__shared__ u32 shared_metadata[256];   // Partition configuration
__shared__ u32 shared_writeouts[256];  // Output staging area
__shared__ u32 shared_state[256];      // Working state (8192 bits)
</code></pre>
<p>The <code>shared_state</code> array holds the current level's values during reduction.</p>
<h2 id="the-reduction-process"><a class="header" href="#the-reduction-process">The Reduction Process</a></h2>
<h3 id="phase-1-level-0--level-1-hier0"><a class="header" href="#phase-1-level-0--level-1-hier0">Phase 1: Level 0 → Level 1 (hier[0])</a></h3>
<p>Only threads 128-255 are active. Each computes 32 AND gates in parallel:</p>
<pre><code class="language-cpp">if(threadIdx.x &gt;= 128) {
    u32 hier_input_a = shared_state[threadIdx.x - 128];  // From threads 0-127
    u32 hier_input_b = hier_input;                        // This thread's data

    // 32 AND gates computed simultaneously (one per bit)
    u32 ret = (hier_input_a ^ hier_flag_xora) &amp;
              ((hier_input_b ^ hier_flag_xorb) | hier_flag_orb);

    shared_state[threadIdx.x] = ret;
}
</code></pre>
<p>The <code>xora</code>, <code>xorb</code>, and <code>orb</code> flags encode:</p>
<ul>
<li><code>xora/xorb</code>: Input inversions (for AND-inverter graph)</li>
<li><code>orb</code>: Passthrough mode (when output equals input A, skip the AND)</li>
</ul>
<p>Visual representation:</p>
<pre><code>Before:  [T0][T1]...[T127] [T128][T129]...[T255]
              │                  │
              └───────┬──────────┘
                      │
                   AND gates (128 threads × 32 bits = 4096 gates)
                      │
                      ▼
After:   [----unused----] [T128][T129]...[T255]
                          (128 × 32 = 4096 results)
</code></pre>
<h3 id="phase-2-levels-1-3-shared-memory"><a class="header" href="#phase-2-levels-1-3-shared-memory">Phase 2: Levels 1-3 (Shared Memory)</a></h3>
<pre><code class="language-cpp">for(int hi = 1; hi &lt;= 3; ++hi) {
    int hier_width = 1 &lt;&lt; (7 - hi);  // 64, 32, 16
    if(threadIdx.x &gt;= hier_width &amp;&amp; threadIdx.x &lt; hier_width * 2) {
        u32 hier_input_a = shared_state[threadIdx.x + hier_width];
        u32 hier_input_b = shared_state[threadIdx.x + hier_width * 2];
        u32 ret = (hier_input_a ^ xora) &amp; ((hier_input_b ^ xorb) | orb);
        shared_state[threadIdx.x] = ret;
    }
    __syncthreads();  // Barrier between levels
}
</code></pre>
<p>Each level activates fewer threads:</p>
<ul>
<li>Level 1: threads 64-127 (64 threads → 2048 gates)</li>
<li>Level 2: threads 32-63 (32 threads → 1024 gates)</li>
<li>Level 3: threads 16-31 (16 threads → 512 gates)</li>
</ul>
<h3 id="phase-3-levels-4-7-warp-shuffle"><a class="header" href="#phase-3-levels-4-7-warp-shuffle">Phase 3: Levels 4-7 (Warp Shuffle)</a></h3>
<p>Within a single warp (32 threads), data exchange uses fast shuffle instructions instead of shared memory:</p>
<pre><code class="language-cpp">if(threadIdx.x &lt; 32) {
    for(int hi = 4; hi &lt;= 7; ++hi) {
        int hier_width = 1 &lt;&lt; (7 - hi);  // 8, 4, 2, 1
        u32 hier_input_a = __shfl_down_sync(0xffffffff, tmp_cur_hi, hier_width);
        u32 hier_input_b = __shfl_down_sync(0xffffffff, tmp_cur_hi, hier_width * 2);
        if(threadIdx.x &gt;= hier_width &amp;&amp; threadIdx.x &lt; hier_width * 2) {
            tmp_cur_hi = (hier_input_a ^ xora) &amp; ((hier_input_b ^ xorb) | orb);
        }
    }
}
</code></pre>
<p>No synchronization needed - warp shuffle is implicitly synchronized.</p>
<h3 id="phase-4-levels-8-12-bit-operations"><a class="header" href="#phase-4-levels-8-12-bit-operations">Phase 4: Levels 8-12 (Bit Operations)</a></h3>
<p>The final levels operate on bits within a single u32, computed by thread 0 only:</p>
<pre><code class="language-cpp">if(threadIdx.x == 0) {
    // Level 8: 32 → 16 (operates on upper/lower halves)
    u32 r8 = ((v1 &lt;&lt; 16) ^ xora) &amp; ((v1 ^ xorb) | orb) &amp; 0xffff0000;

    // Level 9: 16 → 8
    u32 r9 = ((r8 &gt;&gt; 8) ^ xora) &amp; (((r8 &gt;&gt; 16) ^ xorb) | orb) &amp; 0xff00;

    // Level 10: 8 → 4
    u32 r10 = ((r9 &gt;&gt; 4) ^ xora) &amp; (((r9 &gt;&gt; 8) ^ xorb) | orb) &amp; 0xf0;

    // Level 11: 4 → 2
    u32 r11 = ((r10 &gt;&gt; 2) ^ xora) &amp; (((r10 &gt;&gt; 4) ^ xorb) | orb) &amp; 0b1100;

    // Level 12: 2 → 1
    u32 r12 = ((r11 &gt;&gt; 1) ^ xora) &amp; (((r11 &gt;&gt; 2) ^ xorb) | orb) &amp; 0b10;

    tmp_cur_hi = r8 | r9 | r10 | r11 | r12;
}
</code></pre>
<h3 id="write-outs"><a class="header" href="#write-outs">Write-Outs</a></h3>
<p>Results are captured at various levels (not just the final output) and written to global memory:</p>
<pre><code class="language-cpp">if((writeout_hook_i &gt;&gt; 8) == bs_i) {
    shared_writeouts[threadIdx.x] = shared_state[writeout_hook_i &amp; 255];
}
</code></pre>
<p>This is the "return" part of the boomerang - results flow back from intermediate levels.</p>
<h2 id="timing-simulation-approaches"><a class="header" href="#timing-simulation-approaches">Timing Simulation Approaches</a></h2>
<h3 id="approach-comparison"><a class="header" href="#approach-comparison">Approach Comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Parallelism</th><th>Memory</th><th>Accuracy</th><th>GPU Fit</th></tr></thead><tbody>
<tr><td>Event-driven</td><td>Poor (serial queue)</td><td>Low</td><td>Exact</td><td>Bad</td></tr>
<tr><td>Time-wheel</td><td>Medium</td><td>High</td><td>Configurable</td><td>Medium</td></tr>
<tr><td><strong>Levelized</strong></td><td><strong>Excellent</strong></td><td><strong>Low</strong></td><td><strong>Conservative</strong></td><td><strong>Best</strong></td></tr>
<tr><td>Oblivious</td><td>Maximum</td><td>Very High</td><td>Exact</td><td>Wasteful</td></tr>
</tbody></table>
</div>
<h3 id="recommended-levelized-with-delay-accumulation"><a class="header" href="#recommended-levelized-with-delay-accumulation">Recommended: Levelized with Delay Accumulation</a></h3>
<p>This approach piggybacks on the existing boomerang structure with minimal changes.</p>
<h4 id="data-structure-addition"><a class="header" href="#data-structure-addition">Data Structure Addition</a></h4>
<pre><code class="language-cpp">// Add to shared memory (256 bytes additional)
__shared__ u8 shared_arrival[256];  // One arrival time per thread position
</code></pre>
<p>Each thread position stores a single 8-bit arrival time representing the <strong>maximum arrival across all 32 bits</strong> in that position.</p>
<h4 id="modified-and-gate-evaluation"><a class="header" href="#modified-and-gate-evaluation">Modified AND Gate Evaluation</a></h4>
<pre><code class="language-cpp">// Current (value only):
u32 ret = (hier_input_a ^ xora) &amp; ((hier_input_b ^ xorb) | orb);
shared_state[threadIdx.x] = ret;

// With timing (add ~4 instructions):
u32 ret = (hier_input_a ^ xora) &amp; ((hier_input_b ^ xorb) | orb);
shared_state[threadIdx.x] = ret;

u8 arr_a = shared_arrival[threadIdx.x - offset_a];
u8 arr_b = shared_arrival[threadIdx.x - offset_b];
u8 arr_ret = min(max(arr_a, arr_b) + GATE_DELAY, 255);  // Saturating add
shared_arrival[threadIdx.x] = arr_ret;
</code></pre>
<h4 id="complexity-analysis"><a class="header" href="#complexity-analysis">Complexity Analysis</a></h4>
<ul>
<li><strong>Same number of kernel launches</strong> as zero-delay simulation</li>
<li><strong>O(levels × cycles)</strong> - identical to current</li>
<li><strong>~256 bytes additional shared memory</strong> per partition</li>
<li><strong>Estimated 10-20% performance overhead</strong></li>
</ul>
<h2 id="the-approximation-trade-off"><a class="header" href="#the-approximation-trade-off">The Approximation Trade-off</a></h2>
<h3 id="what-we-track"><a class="header" href="#what-we-track">What We Track</a></h3>
<p>One arrival time per thread position (256 values) instead of per signal (8192 values).</p>
<h3 id="implications"><a class="header" href="#implications">Implications</a></h3>
<p>If thread position 50 contains signals A, B, C with different true arrivals:</p>
<pre><code>Signal A: 15ps (shortest path)
Signal B: 23ps (longest path)
Signal C: 8ps  (medium path)
</code></pre>
<p>We store only: <code>arrival[50] = 23ps</code> (the maximum).</p>
<h3 id="why-this-works"><a class="header" href="#why-this-works">Why This Works</a></h3>
<ol>
<li><strong>Conservative</strong>: We might report false violations, but never miss real ones</li>
<li><strong>Correlated signals</strong>: Signals at the same thread position are often topologically nearby with similar timing</li>
<li><strong>Endpoint focus</strong>: We ultimately only care about arrivals at DFF D inputs</li>
</ol>
<h3 id="when-full-accuracy-is-needed"><a class="header" href="#when-full-accuracy-is-needed">When Full Accuracy is Needed</a></h3>
<p>For bit-accurate timing, you would need:</p>
<pre><code class="language-cpp">// 8KB additional shared memory (may exceed limits)
__shared__ u8 shared_arrival[256][32];  // Per-bit arrivals
</code></pre>
<p>This is feasible but significantly increases memory pressure and computation.</p>
<h2 id="implementation-phases"><a class="header" href="#implementation-phases">Implementation Phases</a></h2>
<h3 id="phase-1-cpu-timing-analysis-completed"><a class="header" href="#phase-1-cpu-timing-analysis-completed">Phase 1: CPU Timing Analysis (Completed)</a></h3>
<ul>
<li>Liberty parser for delay extraction</li>
<li>Static timing analysis on AIG</li>
<li>CPU reference simulation with delays</li>
<li>Timing violation detection</li>
</ul>
<h3 id="phase-2-hybrid-gpucpu-completed"><a class="header" href="#phase-2-hybrid-gpucpu-completed">Phase 2: Hybrid GPU+CPU (Completed)</a></h3>
<ul>
<li>GPU performs zero-delay value simulation</li>
<li>CPU performs timing analysis on results</li>
<li>Validates infrastructure without kernel changes</li>
</ul>
<h3 id="phase-3-gpu-arrival-tracking-future"><a class="header" href="#phase-3-gpu-arrival-tracking-future">Phase 3: GPU Arrival Tracking (Future)</a></h3>
<ul>
<li>Add <code>shared_arrival[256]</code> to kernel</li>
<li>Track arrivals during boomerang reduction</li>
<li>Report max arrival at cycle boundaries</li>
<li>Check violations at DFF endpoints</li>
</ul>
<h3 id="phase-4-full-integration-future"><a class="header" href="#phase-4-full-integration-future">Phase 4: Full Integration (Future)</a></h3>
<ul>
<li>Timing violation events via event buffer</li>
<li>Per-cycle timing reports</li>
<li>Integration with output VCD</li>
</ul>
<h2 id="delay-data-encoding"><a class="header" href="#delay-data-encoding">Delay Data Encoding</a></h2>
<h3 id="script-format"><a class="header" href="#script-format">Script Format</a></h3>
<p>The existing boomerang section has padding that can store delay data:</p>
<pre><code>Current format per thread per stage:
  [xora: u32]
  [xorb: u32]
  [orb:  u32]
  [padding: u32]  ← Can store delay here
</code></pre>
<h3 id="packeddelay-structure"><a class="header" href="#packeddelay-structure">PackedDelay Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct PackedDelay {
    pub rise_ps: u16,  // Rising edge delay in picoseconds
    pub fall_ps: u16,  // Falling edge delay in picoseconds
}
<span class="boring">}</span></code></pre></pre>
<p>For simplified timing, a single uniform delay constant can be used instead of per-gate delays.</p>
<h2 id="timing-violation-detection"><a class="header" href="#timing-violation-detection">Timing Violation Detection</a></h2>
<h3 id="at-each-cycle-boundary"><a class="header" href="#at-each-cycle-boundary">At Each Cycle Boundary</a></h3>
<p>The GPU kernel checks timing constraints per state word (32 signals) after the boomerang evaluation completes. Arrivals and constraints use <strong>u16 picosecond</strong> values (range 0–65535 ps). Arithmetic is performed in <strong>u32</strong> to avoid overflow when summing arrival + setup:</p>
<pre><code class="language-cpp">// After boomerang completes, before next cycle
// arrival: u16 max accumulated delay for this 32-signal group
// constraint_word: packed [setup_ps:16][hold_ps:16]
u16 setup_ps = constraint_word &gt;&gt; 16;
u16 hold_ps  = constraint_word &amp; 0xFFFF;

// Setup check: skip when arrival == 0 (no data propagated, e.g. first cycle
// or DFF with constant inputs)
if (arrival &gt; 0 &amp;&amp; (u32)arrival + (u32)setup_ps &gt; clock_period_ps) {
    int slack = (int)clock_period_ps - (int)arrival - (int)setup_ps;
    write_event(event_buffer, EVENT_TYPE_SETUP_VIOLATION,
                cycle, io_offset + threadIdx.x,
                (u32)slack, (u32)arrival, (u32)setup_ps);
}

// Hold check: no arrival &gt; 0 guard (hold violations matter even at cycle 0)
if ((u32)arrival &lt; (u32)hold_ps) {
    int slack = (int)arrival - (int)hold_ps;
    write_event(event_buffer, EVENT_TYPE_HOLD_VIOLATION,
                cycle, io_offset + threadIdx.x,
                (u32)slack, (u32)arrival, (u32)hold_ps);
}
</code></pre>
<h3 id="event-buffer-integration"><a class="header" href="#event-buffer-integration">Event Buffer Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum EventType {
    Stop = 0,
    Finish = 1,
    Display = 2,
    AssertFail = 3,
    SetupViolation = 4,   // Timing events
    HoldViolation = 5,
}
<span class="boring">}</span></code></pre></pre>
<p>For full details on interpreting violation reports and tracing violations to source signals, see <a href="timing-violations.html">docs/timing-violations.md</a>.</p>
<h2 id="timing-aware-bit-packing"><a class="header" href="#timing-aware-bit-packing">Timing-Aware Bit Packing</a></h2>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>Each thread position holds 32 signals packed into a u32. When tracking timing with one arrival value per thread position, we approximate all 32 signals as having the same arrival time (the maximum).</p>
<p>This approximation is accurate when signals in the same thread have similar timing. But the default placement algorithm uses <strong>first-fit</strong> for bit assignment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default: first available slot
for i in 0..hier[selected_level].len() {
    if hier[selected_level][i] == usize::MAX {
        slot_at_level = i;  // First-fit, not timing-aware
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This can result in signals with very different timing sharing a thread:</p>
<pre><code>Thread 50 (accidental grouping):
  bit 0: level 5,  ~5ps arrival
  bit 1: level 12, ~12ps arrival  ← 7ps difference!
  bit 2: level 6,  ~6ps arrival

Thread 50 (timing-aware grouping):
  bit 0: level 5, ~5ps arrival
  bit 1: level 5, ~5ps arrival    ← similar timing
  bit 2: level 6, ~6ps arrival
</code></pre>
<h3 id="current-timing-correlation"><a class="header" href="#current-timing-correlation">Current Timing Correlation</a></h3>
<p>The placement algorithm already computes <strong>logic levels</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Level = max(level of inputs) + 1
level[node] = max(level[input_a], level[input_b]) + 1;
<span class="boring">}</span></code></pre></pre>
<p>Logic level correlates with timing (more levels = more gate delays), but signals at the same level can still have different actual delays due to:</p>
<ul>
<li>Different gate types (AND2_00_0 vs AND2_11_1)</li>
<li>Different wire loads</li>
<li>Path reconvergence</li>
</ul>
<h3 id="solution-sort-by-timing-before-packing"><a class="header" href="#solution-sort-by-timing-before-packing">Solution: Sort by Timing Before Packing</a></h3>
<p>Before assigning bit positions, sort signals by their estimated arrival time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Collect nodes at this level
let mut nodes_to_place: Vec&lt;_&gt; = candidates
    .filter(|n| level[n] == selected_level)
    .collect();

// Sort by arrival time (level as proxy, or actual timing if available)
nodes_to_place.sort_by_key(|n| arrival_estimate[n]);

// Place in sorted order - similar timing ends up in same thread
for (slot, node) in nodes_to_place.iter().enumerate() {
    place_bit(..., slot, *node);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Complexity</th><th>Effectiveness</th><th>When to Use</th></tr></thead><tbody>
<tr><td><strong>Sort by timing</strong></td><td>Low</td><td>Good</td><td>Default choice</td></tr>
<tr><td>Timing-aware partitioning</td><td>High</td><td>Best</td><td>Large designs</td></tr>
<tr><td>Post-placement swapping</td><td>Medium</td><td>Good</td><td>Fine-tuning</td></tr>
<tr><td>Timing bands</td><td>Low</td><td>Moderate</td><td>Simple heuristic</td></tr>
</tbody></table>
</div>
<h3 id="timing-bands"><a class="header" href="#timing-bands">Timing Bands</a></h3>
<p>Group signals into arrival time bands:</p>
<pre><code>Band 0: 0-10ps   → Threads 0-63
Band 1: 10-20ps  → Threads 64-127
Band 2: 20-30ps  → Threads 128-191
Band 3: 30+ps    → Threads 192-255
</code></pre>
<h3 id="measuring-packing-quality"><a class="header" href="#measuring-packing-quality">Measuring Packing Quality</a></h3>
<p>Diagnostic to measure timing variance per thread:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn analyze_timing_packing(hier: &amp;Hierarchy, arrivals: &amp;[u64]) {
    for thread in 0..256 {
        let times: Vec&lt;_&gt; = get_bits_in_thread(hier, thread)
            .map(|b| arrivals[b])
            .collect();

        let range = times.iter().max() - times.iter().min();
        let variance = compute_variance(&amp;times);

        if range &gt; threshold {
            warn!("Thread {} has {}ps timing spread", thread, range);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="impact-on-approximation-accuracy"><a class="header" href="#impact-on-approximation-accuracy">Impact on Approximation Accuracy</a></h3>
<p>With timing-aware packing:</p>
<ul>
<li><strong>Reduced false positives</strong>: Fewer spurious timing violations from max approximation</li>
<li><strong>Tighter bounds</strong>: Per-thread arrival closer to actual signal arrivals</li>
<li><strong>Better critical path identification</strong>: Max arrival more accurately reflects true critical path</li>
</ul>
<h2 id="performance-expectations"><a class="header" href="#performance-expectations">Performance Expectations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Zero-Delay</th><th>With Timing</th></tr></thead><tbody>
<tr><td>Kernel launches</td><td>N</td><td>N</td></tr>
<tr><td>Shared memory</td><td>3KB</td><td>3.25KB</td></tr>
<tr><td>Registers</td><td>~32</td><td>~36</td></tr>
<tr><td>Instructions/gate</td><td>~5</td><td>~9</td></tr>
<tr><td><strong>Estimated overhead</strong></td><td>-</td><td><strong>15-25%</strong></td></tr>
</tbody></table>
</div>
<p>The overhead is modest because:</p>
<ol>
<li>Timing operations are simple (max, add)</li>
<li>Memory access pattern is identical</li>
<li>No additional synchronization needed</li>
<li>Same parallelism structure</li>
</ol>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><code>src/pe.rs</code> - Partition executor and boomerang stage construction</li>
<li><code>csrc/kernel_v1_impl.cuh</code> - GPU kernel implementation</li>
<li><code>src/flatten.rs</code> - Script generation with timing data</li>
<li><code>src/event_buffer.rs</code> - GPU→CPU event communication</li>
<li><code>src/liberty_parser.rs</code> - Timing library parsing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timing-violation-detection-1"><a class="header" href="#timing-violation-detection-1">Timing Violation Detection</a></h1>
<p>Guide to enabling, reading, and debugging setup/hold timing violations in GEM.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Setup and hold violations occur when data arrives too late (setup) or too early (hold) relative to the clock edge at a flip-flop. GEM checks for these violations during GPU simulation by tracking <strong>arrival times</strong> — the accumulated gate delay from primary inputs or DFF outputs through combinational logic to the next DFF data input.</p>
<p><strong>Approximation model</strong>: GEM tracks one arrival time per 32-signal group (one GPU thread position). The arrival is the <strong>maximum</strong> across all 32 signals in the group. This is conservative: it may over-report violations but will never miss a real one. See <a href="timing-violations.html#the-approximation-caveat">Reducing False Positives</a> for details.</p>
<h2 id="enabling-timing-checks"><a class="header" href="#enabling-timing-checks">Enabling Timing Checks</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ol>
<li><strong>SDF file</strong> with back-annotated delays from your place-and-route tool</li>
<li><strong>Gate-level netlist</strong> synthesized to <code>aigpdk.lib</code> cells</li>
<li><strong>Compiled <code>.gemparts</code></strong> file from <code>loom map</code></li>
</ol>
<h3 id="step-by-step"><a class="header" href="#step-by-step">Step-by-step</a></h3>
<ol>
<li>
<p><strong>Generate SDF</strong> from your P&amp;R tool (or use <code>scripts/generate_sdf.py</code> for test designs):</p>
<pre><code class="language-bash"># Example: OpenROAD flow output
ls my_build/6_final.sdf
</code></pre>
</li>
<li>
<p><strong>Run the simulator</strong> with <code>--sdf</code> and a clock period:</p>
<p><strong>Metal (macOS)</strong>:</p>
<pre><code class="language-bash">cargo run -r --features metal --bin loom -- sim \
    design.gv design.gemparts input.vcd output.vcd 1 \
    --sdf design.sdf \
    --sdf-corner typ
</code></pre>
<p><strong>CUDA (NVIDIA)</strong>:</p>
<pre><code class="language-bash">cargo run -r --features cuda --bin loom -- sim \
    design.gv design.gemparts input.vcd output.vcd 8 \
    --sdf design.sdf \
    --sdf-corner typ \
    --enable-timing \
    --timing-clock-period 1200
</code></pre>
<p><strong>gpu_sim (co-simulation)</strong>:</p>
<pre><code class="language-bash">cargo run -r --features metal --bin gpu_sim -- \
    design.gv design.gemparts \
    --config testbench.json \
    --sdf design.sdf \
    --sdf-corner typ
</code></pre>
</li>
</ol>
<h3 id="cli-flags-reference"><a class="header" href="#cli-flags-reference">CLI Flags Reference</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Binary</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--sdf &lt;path&gt;</code></td><td>all</td><td>Path to SDF file with back-annotated delays</td></tr>
<tr><td><code>--sdf-corner &lt;min|typ|max&gt;</code></td><td>all</td><td>Which SDF corner to use (default: <code>typ</code>)</td></tr>
<tr><td><code>--sdf-debug</code></td><td>all</td><td>Print unmatched SDF instances for debugging</td></tr>
<tr><td><code>--enable-timing</code></td><td><code>loom sim</code></td><td>Enable timing analysis (arrival + violation checks)</td></tr>
<tr><td><code>--timing-clock-period &lt;ps&gt;</code></td><td><code>loom sim</code></td><td>Clock period in picoseconds (default: 1000)</td></tr>
<tr><td><code>--timing-report-violations</code></td><td><code>loom sim</code></td><td>Report all violations, not just summary</td></tr>
<tr><td><code>--liberty &lt;path&gt;</code></td><td><code>loom sim</code></td><td>Liberty library for timing data (optional, falls back to AIGPDK defaults)</td></tr>
</tbody></table>
</div>
<h3 id="example-inv_chain_pnr-test-case"><a class="header" href="#example-inv_chain_pnr-test-case">Example: inv_chain_pnr Test Case</a></h3>
<pre><code class="language-bash"># Map the design
cargo run -r --features metal --bin loom -- map \
    tests/timing_test/inv_chain_pnr/6_final.v \
    tests/timing_test/inv_chain_pnr/inv_chain.gemparts

# Run with SDF timing
cargo run -r --features metal --bin loom -- sim \
    tests/timing_test/inv_chain_pnr/6_final.v \
    tests/timing_test/inv_chain_pnr/inv_chain.gemparts \
    tests/timing_test/inv_chain_pnr/input.vcd \
    tests/timing_test/inv_chain_pnr/output.vcd 1 \
    --sdf tests/timing_test/inv_chain_pnr/6_final.sdf
</code></pre>
<h2 id="reading-violation-reports"><a class="header" href="#reading-violation-reports">Reading Violation Reports</a></h2>
<h3 id="setup-violation-format"><a class="header" href="#setup-violation-format">Setup Violation Format</a></h3>
<pre><code>[cycle 42] SETUP VIOLATION: word 5 arrival=900ps setup=200ps slack=-100ps
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Meaning</th></tr></thead><tbody>
<tr><td><strong>cycle</strong></td><td>Simulation cycle where the violation occurred</td></tr>
<tr><td><strong>word</strong></td><td>State word index — identifies a group of 32 DFF data inputs</td></tr>
<tr><td><strong>arrival</strong></td><td>Maximum accumulated gate delay to this word's signals (picoseconds)</td></tr>
<tr><td><strong>setup</strong></td><td>DFF setup time constraint from SDF/Liberty (picoseconds)</td></tr>
<tr><td><strong>slack</strong></td><td><code>clock_period - arrival - setup</code>. Negative = violation amount</td></tr>
</tbody></table>
</div>
<h3 id="hold-violation-format"><a class="header" href="#hold-violation-format">Hold Violation Format</a></h3>
<pre><code>[cycle 11] HOLD VIOLATION: word 3 arrival=10ps hold=50ps slack=-40ps
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Meaning</th></tr></thead><tbody>
<tr><td><strong>cycle</strong></td><td>Simulation cycle where the violation occurred</td></tr>
<tr><td><strong>word</strong></td><td>State word index</td></tr>
<tr><td><strong>arrival</strong></td><td>Accumulated gate delay to this word's signals (picoseconds)</td></tr>
<tr><td><strong>hold</strong></td><td>DFF hold time constraint from SDF/Liberty (picoseconds)</td></tr>
<tr><td><strong>slack</strong></td><td><code>arrival - hold</code>. Negative = violation amount</td></tr>
</tbody></table>
</div>
<h3 id="summary-statistics"><a class="header" href="#summary-statistics">Summary Statistics</a></h3>
<p>At the end of simulation, GEM prints totals:</p>
<pre><code>Simulation complete: 1000 cycles, 5 setup violations, 0 hold violations
</code></pre>
<h2 id="tracing-violations-to-source-signals"><a class="header" href="#tracing-violations-to-source-signals">Tracing Violations to Source Signals</a></h2>
<p>When you see a violation on a specific word, follow this workflow to identify the offending signals and their logic cone.</p>
<h3 id="1-get-the-word-index"><a class="header" href="#1-get-the-word-index">1. Get the Word Index</a></h3>
<p>From the log: <code>word 5</code> means state word index 5.</p>
<h3 id="2-map-word-to-dff-signals"><a class="header" href="#2-map-word-to-dff-signals">2. Map Word to DFF Signals</a></h3>
<p>Each word covers 32 bits of state. The DFFs in that word have <code>data_state_pos / 32 == word_index</code>. To find which DFFs:</p>
<ul>
<li>
<p>Look at the <code>dff_constraints</code> entries in the <code>FlattenedScriptV1</code>:</p>
<pre><code>dff_constraints entries where data_state_pos / 32 == 5
→ cell_id values → netlist cell names
</code></pre>
</li>
<li>
<p>In <code>gpu_sim</code>, violations are logged with word IDs that map directly to the <code>output_map</code> positions. Each word covers bit positions <code>word * 32</code> through <code>word * 32 + 31</code>.</p>
</li>
</ul>
<h3 id="3-trace-backwards-with-netlist_graph"><a class="header" href="#3-trace-backwards-with-netlist_graph">3. Trace Backwards with netlist_graph</a></h3>
<p>Use the <a href="../scripts/netlist_graph/">netlist_graph tool</a> to trace the combinational logic cone feeding the DFF:</p>
<pre><code class="language-bash">cd scripts/netlist_graph

# Find the DFF data input driver chain
uv run netlist-graph drivers design.v "dff_name.D" -d 10

# Search for DFFs matching a pattern
uv run netlist-graph search design.v "dff_out*"
</code></pre>
<h3 id="4-detailed-cpu-timing-analysis"><a class="header" href="#4-detailed-cpu-timing-analysis">4. Detailed CPU Timing Analysis</a></h3>
<p>For per-signal accuracy (no 32-signal approximation), use <code>timing_sim_cpu</code>:</p>
<pre><code class="language-bash"># Generate a watchlist for signals of interest
cd scripts/netlist_graph
uv run netlist-graph watchlist design.v watch.json dff_name signal1 signal2

# Run CPU timing simulation with per-signal tracing
cargo run -r --bin timing_sim_cpu -- design.v input.vcd \
    --liberty sky130.lib --clock-period 1200 \
    --watchlist watch.json --trace-output trace.csv
</code></pre>
<p>The CSV trace shows per-cycle arrival times for each watched signal, allowing you to pinpoint exactly which path is critical.</p>
<h2 id="the-approximation-caveat"><a class="header" href="#the-approximation-caveat">The Approximation Caveat</a></h2>
<p>GEM tracks <strong>one arrival time per 32-signal group</strong> (one GPU thread position). The tracked value is the maximum arrival across all 32 signals in that thread. This means:</p>
<ul>
<li><strong>Conservative</strong>: If any signal in the group has a long path, the arrival for the entire group reflects that worst case. Violations may be reported for signals that individually meet timing.</li>
<li><strong>Never misses real violations</strong>: A real violation always results in a reported violation (the max is &gt;= any individual signal's arrival).</li>
</ul>
<h3 id="reducing-false-positives"><a class="header" href="#reducing-false-positives">Reducing False Positives</a></h3>
<p>If a violation is reported but you suspect it's a false positive from the approximation:</p>
<ol>
<li><strong>Use <code>timing_sim_cpu</code></strong> for per-signal accuracy (see <a href="timing-violations.html#4-detailed-cpu-timing-analysis">Detailed CPU Timing Analysis</a> above).</li>
<li><strong>Timing-aware bit packing</strong> groups signals with similar arrival times into the same thread, reducing the approximation error. See <code>docs/timing-simulation.md</code> § "Timing-Aware Bit Packing" for details.</li>
</ol>
<h2 id="common-scenarios"><a class="header" href="#common-scenarios">Common Scenarios</a></h2>
<p><strong>Setup violations on many words, same cycle</strong>: The clock period is likely too tight for the design. The combinational logic depth exceeds what can settle in one clock period. Try increasing the clock period.</p>
<p><strong>Setup violation on a single word</strong>: A critical path through one specific logic cone. Use <code>netlist_graph drivers</code> to trace the path and identify the bottleneck.</p>
<p><strong>Hold violation</strong>: Rare with SKY130 process (negative hold times clamp to 0 in the SDF). If seen, the design likely has minimum-delay paths that are too short. Check for direct connections between DFF outputs and nearby DFF inputs with minimal combinational logic.</p>
<p><strong>Violations only on first cycle</strong>: The <code>arrival &gt; 0</code> guard in the GPU kernel skips setup checks when arrival is zero (meaning no data has propagated through combinational logic yet). If you see violations on cycle 0, they are hold violations — setup violations on cycle 0 are suppressed by design.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-vcd-input-issues"><a class="header" href="#troubleshooting-vcd-input-issues">Troubleshooting VCD Input Issues</a></h1>
<p>This guide helps debug VCD input problems where GEM simulations produce incorrect results or warn about missing signals.</p>
<h2 id="vcd-scope-auto-detection-recommended"><a class="header" href="#vcd-scope-auto-detection-recommended">VCD Scope Auto-Detection (Recommended)</a></h2>
<p><strong>NEW</strong>: GEM now automatically detects the correct VCD scope containing your design's ports. In most cases, you don't need to specify <code>--input-vcd-scope</code> manually.</p>
<h3 id="how-auto-detection-works"><a class="header" href="#how-auto-detection-works">How Auto-Detection Works</a></h3>
<p>When you run <code>loom sim</code> without specifying <code>--input-vcd-scope</code>, GEM:</p>
<ol>
<li>Extracts the list of required input ports from your synthesized design</li>
<li>Searches the VCD file for scopes containing all required ports</li>
<li>Tries common DUT scope names first: <code>dut</code>, <code>uut</code>, <code>DUT</code>, <code>UUT</code>, or your module name</li>
<li>Falls back to any scope that contains all required ports</li>
<li>Logs which scope was selected for transparency</li>
</ol>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code>INFO No VCD scope specified - attempting auto-detection
DEBUG Searching for VCD scope containing 4 input ports
DEBUG Required ports: {"din_valid", "clk", "reset", "din"}
INFO Auto-detected VCD scope: safe_tb/uut (matched common pattern 'uut')
</code></pre>
<h3 id="manual-override"><a class="header" href="#manual-override">Manual Override</a></h3>
<p>If auto-detection fails or selects the wrong scope, use <code>--input-vcd-scope</code> to specify manually:</p>
<pre><code class="language-bash"># Slash-separated path to the DUT scope
loom sim design.gv design.gemparts input.vcd output.vcd 8 \
    --input-vcd-scope "testbench/dut"

# For nested hierarchies
loom sim design.gv design.gemparts input.vcd output.vcd 8 \
    --input-vcd-scope "top_tb/subsystem/my_module"
</code></pre>
<p><strong>Note</strong>: Use slash separators (<code>/</code>), not dots (<code>.</code>).</p>
<hr />
<h2 id="symptom-missing-primary-input-warnings"><a class="header" href="#symptom-missing-primary-input-warnings">Symptom: Missing Primary Input Warnings</a></h2>
<pre><code>WARN (GATESIM_VCDI_MISSING_PI) Primary input port (HierName(), "reset", None) not present in the VCD input
WARN (GATESIM_VCDI_MISSING_PI) Primary input port (HierName(), "din", Some(3)) not present in the VCD input
</code></pre>
<h3 id="root-cause"><a class="header" href="#root-cause">Root Cause</a></h3>
<p>GEM expects VCD signals at <strong>absolute top-level</strong> with no module hierarchy prefix. The signal names must exactly match the synthesized module's port names.</p>
<h3 id="how-to-check"><a class="header" href="#how-to-check">How to Check</a></h3>
<ol>
<li><strong>Inspect your VCD file</strong>:</li>
</ol>
<pre><code class="language-bash">grep '\$var' your_input.vcd | head -20
</code></pre>
<ol start="2">
<li><strong>Look for module scopes</strong>:</li>
</ol>
<pre><code class="language-bash">grep '\$scope module' your_input.vcd
</code></pre>
<ol start="3">
<li><strong>Check synthesized module ports</strong>:</li>
</ol>
<pre><code class="language-bash">head -20 your_design_synth.gv
</code></pre>
<h3 id="what-gem-expects"><a class="header" href="#what-gem-expects">What GEM Expects</a></h3>
<p><strong>Correct</strong> - Signals at top level:</p>
<pre><code class="language-vcd">$timescale 1ns/1ns
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var reg 4 # din [3:0] $end
$var reg 1 $ din_valid $end
$var wire 1 % unlocked $end
$enddefinitions $end
$dumpvars
0"
0$
0%
1!
#10
1"
#20
b1100 #
1$
</code></pre>
<p><strong>Incorrect</strong> - Signals scoped under module:</p>
<pre><code class="language-vcd">$scope module testbench $end
  $scope module dut $end
    $var wire 1 ! clk $end
    $var wire 1 " reset $end
    $var wire 4 # din [3:0] $end
    ...
  $upscope $end
$upscope $end
</code></pre>
<h2 id="solution-1-flat-vcd-generation"><a class="header" href="#solution-1-flat-vcd-generation">Solution 1: Flat VCD Generation</a></h2>
<p>Create a testbench that dumps signals at absolute top level:</p>
<pre><code class="language-verilog">module testbench;

reg clk = 0;
reg reset;
reg [3:0] din;
reg din_valid = 0;
wire unlocked;

// DUT instantiation
your_module dut (
    .clk(clk),
    .reset(reset),
    .din(din),
    .din_valid(din_valid),
    .unlocked(unlocked)
);

always #10 clk = !clk;

initial begin
    // CRITICAL: Dump signals at top level (depth 1)
    // NOT inside module hierarchy!
    $dumpfile("output.vcd");
    $dumpvars(1, clk, reset, din, din_valid, unlocked);

    // Test sequence
    reset = 1;
    #60;
    reset = 0;

    // ... your test stimulus ...

    #200;
    $finish;
end

endmodule
</code></pre>
<p><strong>Key Point</strong>: <code>$dumpvars(1, signal1, signal2, ...)</code> dumps individual signals at the current scope level, <strong>not</strong> inside child modules.</p>
<h3 id="compile-and-run"><a class="header" href="#compile-and-run">Compile and Run</a></h3>
<pre><code class="language-bash"># For synthesis-compatible testbench
iverilog -DSYNTHESIS -o sim your_design.v testbench.v
./sim

# Check VCD structure
grep '\$scope' output.vcd  # Should be minimal or none
grep '\$var' output.vcd | head -10
</code></pre>
<h2 id="solution-2-post-process-vcd-advanced"><a class="header" href="#solution-2-post-process-vcd-advanced">Solution 2: Post-Process VCD (Advanced)</a></h2>
<p>If you can't change the testbench, post-process the VCD to flatten hierarchy:</p>
<pre><code class="language-python">#!/usr/bin/env python3
"""Flatten VCD hierarchy to top level"""

import sys

def flatten_vcd(input_vcd, output_vcd):
    with open(input_vcd) as inf, open(output_vcd, 'w') as outf:
        in_scope = False
        scope_depth = 0

        for line in inf:
            # Track scope depth
            if line.strip().startswith('$scope'):
                scope_depth += 1
                if scope_depth == 1:
                    continue  # Keep root scope
                in_scope = True
                continue
            elif line.strip().startswith('$upscope'):
                scope_depth -= 1
                if in_scope and scope_depth == 0:
                    in_scope = False
                continue

            # Skip signals inside nested scopes, keep only top-level
            if in_scope and line.strip().startswith('$var'):
                continue  # Skip nested module signals

            outf.write(line)

if __name__ == '__main__':
    flatten_vcd(sys.argv[1], sys.argv[2])
</code></pre>
<p><strong>Usage</strong>:</p>
<pre><code class="language-bash">python3 flatten_vcd.py hierarchical.vcd flat.vcd
</code></pre>
<h2 id="solution-3-vcd-scope-option-experimental"><a class="header" href="#solution-3-vcd-scope-option-experimental">Solution 3: VCD Scope Option (Experimental)</a></h2>
<p>GEM provides <code>--input-vcd-scope</code> to specify which module hierarchy to read:</p>
<pre><code class="language-bash">cargo run -r --features metal --bin loom -- sim \
    design.gv parts.gemparts input.vcd output.vcd 48 \
    --input-vcd-scope module_name
</code></pre>
<p><strong>Known Issue</strong>: Currently, signal matching still fails even with correct scope specified. This is under investigation.</p>
<h2 id="diagnostic-checklist"><a class="header" href="#diagnostic-checklist">Diagnostic Checklist</a></h2>
<h3 id="1-verify-signal-names-match"><a class="header" href="#1-verify-signal-names-match">1. Verify Signal Names Match</a></h3>
<p><strong>Synthesized Module</strong>:</p>
<pre><code class="language-bash">grep "^module\|input\|output" design_synth.gv
</code></pre>
<p>Output:</p>
<pre><code class="language-verilog">module safe(clk, reset, din, din_valid, unlocked);
  input clk;
  input reset;
  input [3:0] din;
  input din_valid;
  output unlocked;
</code></pre>
<p><strong>VCD Signals</strong>:</p>
<pre><code class="language-bash">grep '\$var.*\(clk\|reset\|din\|unlocked\)' input.vcd
</code></pre>
<p>Output should match synthesized port names exactly.</p>
<h3 id="2-check-signal-bit-widths"><a class="header" href="#2-check-signal-bit-widths">2. Check Signal Bit Widths</a></h3>
<p>Multi-bit signals must have correct indices:</p>
<p><strong>Synthesized</strong>: <code>input [3:0] din;</code></p>
<p><strong>VCD</strong>:</p>
<pre><code class="language-vcd">$var reg 4 # din [3:0] $end
</code></pre>
<p>GEM expects separate indices: <code>din[3]</code>, <code>din[2]</code>, <code>din[1]</code>, <code>din[0]</code></p>
<h3 id="3-verify-timestamp-format"><a class="header" href="#3-verify-timestamp-format">3. Verify Timestamp Format</a></h3>
<p>GEM expects integer timestamps (not real numbers):</p>
<p><strong>Correct</strong>:</p>
<pre><code class="language-vcd">#0
#10
#20
</code></pre>
<p><strong>Incorrect</strong>:</p>
<pre><code class="language-vcd">#0.0
#10.5
#20.25
</code></pre>
<h3 id="4-check-timescale"><a class="header" href="#4-check-timescale">4. Check Timescale</a></h3>
<p>Ensure VCD timescale matches simulation expectations:</p>
<pre><code class="language-vcd">$timescale 1ns $end
</code></pre>
<p>or</p>
<pre><code class="language-vcd">$timescale 1ps $end
</code></pre>
<p>Clock periods in testbench should use same time unit.</p>
<h2 id="validation-steps"><a class="header" href="#validation-steps">Validation Steps</a></h2>
<p>After fixing VCD issues, validate GEM is reading inputs correctly:</p>
<h3 id="1-run-with-cpu-verification"><a class="header" href="#1-run-with-cpu-verification">1. Run with CPU Verification</a></h3>
<pre><code class="language-bash">cargo run -r --features metal --bin loom -- sim \
    design.gv parts.gemparts input.vcd output.vcd 48 \
    --check-with-cpu
</code></pre>
<p>This compares GPU results against CPU gate-level simulation. Should print:</p>
<pre><code>[INFO] sanity test passed!
</code></pre>
<h3 id="2-compare-output-vcd-with-reference"><a class="header" href="#2-compare-output-vcd-with-reference">2. Compare Output VCD with Reference</a></h3>
<p>Run same design with iverilog:</p>
<pre><code class="language-bash">iverilog -o reference_sim design.v testbench.v
./reference_sim  # Generates reference.vcd
</code></pre>
<p>Compare outputs:</p>
<pre><code class="language-bash"># Check if unlocked signal toggles the same in both
grep '^[01]!' gem_output.vcd
grep '^[01]!' reference.vcd
</code></pre>
<h3 id="3-check-cycle-count"><a class="header" href="#3-check-cycle-count">3. Check Cycle Count</a></h3>
<pre><code class="language-bash">cargo run -r --features metal --bin loom -- sim \
    design.gv parts.gemparts input.vcd output.vcd 48 \
    2&gt;&amp;1 | grep "total number of cycles"
</code></pre>
<p>Should match your testbench's simulation time / clock period.</p>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-testbench-inside-ifndef-synthesis"><a class="header" href="#1-testbench-inside-ifndef-synthesis">1. Testbench Inside `ifndef SYNTHESIS</a></h3>
<p>If testbench is only compiled when <code>SYNTHESIS</code> is not defined:</p>
<pre><code class="language-verilog">`ifndef SYNTHESIS
module testbench;
  // ...
endmodule
`endif
</code></pre>
<p>You must compile <strong>without</strong> <code>-DSYNTHESIS</code> for VCD generation:</p>
<pre><code class="language-bash">iverilog -o sim design.v testbench.v  # No -DSYNTHESIS!
</code></pre>
<p>But the DUT must be compiled <strong>with</strong> <code>-DSYNTHESIS</code> if it has non-synthesizable constructs:</p>
<pre><code class="language-bash"># Separate compilation
iverilog -DSYNTHESIS -c design.v
iverilog -o sim design.v testbench.v
</code></pre>
<h3 id="2-xz-values-in-vcd"><a class="header" href="#2-xz-values-in-vcd">2. X/Z Values in VCD</a></h3>
<p>GEM may not handle unknown (X) or high-impedance (Z) values correctly:</p>
<pre><code class="language-vcd">$dumpvars
x"  # reset = X
bxxxx #  # din = XXXX
</code></pre>
<p><strong>Solution</strong>: Initialize all inputs in testbench:</p>
<pre><code class="language-verilog">initial begin
    reset = 0;  // Don't leave uninitialized
    din = 4'h0;
    din_valid = 0;
end
</code></pre>
<h3 id="3-missing-clock-signal"><a class="header" href="#3-missing-clock-signal">3. Missing Clock Signal</a></h3>
<p>If VCD doesn't include clock:</p>
<pre><code>WARN (GATESIM_VCDI_MISSING_PI) Primary input port (HierName(), "clk", None) not present
</code></pre>
<p><strong>Ensure</strong>:</p>
<ul>
<li>Clock is generated in testbench</li>
<li>Clock is included in <code>$dumpvars</code></li>
<li>Clock signal name matches synthesized netlist exactly</li>
</ul>
<h2 id="example-working-flat-vcd-testbench"><a class="header" href="#example-working-flat-vcd-testbench">Example: Working Flat VCD Testbench</a></h2>
<pre><code class="language-verilog">// testbench_flat.v - Generates GEM-compatible VCD
module testbench_flat;

// Declare all signals at top level
reg clk = 0;
reg reset = 1;
reg [3:0] din = 4'h0;
reg din_valid = 0;
wire unlocked;

// DUT instantiation
safe dut (
    .clk(clk),
    .reset(reset),
    .din(din),
    .din_valid(din_valid),
    .unlocked(unlocked)
);

// Clock generation
always #10 clk = !clk;  // 20ns period = 50MHz

// Test sequence
initial begin
    // CRITICAL: Dump at top level (depth 1)
    $dumpfile("safe_flat.vcd");
    $dumpvars(1, clk, reset, din, din_valid, unlocked);

    // Reset phase
    reset = 1;
    #60;  // 3 clock cycles
    reset = 0;
    #11;  // Small offset from clock edge

    // Apply test stimulus
    din = 4'hc;
    din_valid = 1;
    #20;

    din = 4'h0;
    #20;

    din = 4'hd;
    #20;

    din = 4'he;
    #20;

    din_valid = 0;
    #40;

    $finish;
end

endmodule
</code></pre>
<p><strong>Compile and test</strong>:</p>
<pre><code class="language-bash"># Compile (DUT must be SYNTHESIS-compatible)
iverilog -DSYNTHESIS -o sim safe.v testbench_flat.v

# Run simulation
./sim

# Verify VCD structure
echo "=== VCD Scopes ==="
grep '\$scope' safe_flat.vcd

echo -e "\n=== VCD Signals ==="
grep '\$var' safe_flat.vcd

# Should show signals at top level, no nested $scope modules
</code></pre>
<h2 id="still-having-issues"><a class="header" href="#still-having-issues">Still Having Issues?</a></h2>
<ol>
<li>
<p><strong>Enable debug logging</strong>:</p>
<pre><code class="language-bash">RUST_LOG=debug,vcd_ng=trace cargo run -r --features metal --bin loom -- sim &lt;args&gt; 2&gt;&amp;1 | tee debug.log
</code></pre>
</li>
<li>
<p><strong>Check with minimal test</strong>:</p>
<ul>
<li>Create simplest possible design (single DFF)</li>
<li>Generate flat VCD</li>
<li>Verify GEM can read it correctly</li>
</ul>
</li>
<li>
<p><strong>Report issue</strong> with:</p>
<ul>
<li>Synthesized <code>.gv</code> file</li>
<li>Input VCD file</li>
<li>GEM command line</li>
<li>Error messages or unexpected output</li>
</ul>
</li>
</ol>
<hr />
<p><strong>Document Version</strong>: 1.0
<strong>Last Updated</strong>: 2025-01-08
<strong>Related</strong>: simulation-architecture.md</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
