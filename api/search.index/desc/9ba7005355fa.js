rd_("AmThe Q pin output with invert.0AbPartition executor0BcAn AIG associated with a netlistdb.0AbSingle-bit signal.0B`Driven by a DFF (with its index)fA DFF.10AnLog the violation and continueAlLog the failure and continue10AiAnd-inverter graph format0BmLoom \xe2\x80\x94 GPU-accelerated RTL logic simulator.BoGet the current number of events in the buffer.BiNet name pattern to match in the netlist.CiCreate a new CellInputs with all pins set to MAX (unset).CnCreate a new traverser for an AIG with the given number of \xe2\x80\xa6BnCreate a new PackedDelay from rise/fall times.B`Create a new empty event buffer.DhCreate a new UART monitor. <code>clock_hz</code> is the system clock \xe2\x80\xa6CgShared simulation infrastructure for GPU simulation \xe2\x80\xa6CgDriven by a 13-bit by 32-bit RAM block (with its index)Ah$stop - pause simulationBd$stop system task - pause simulationCkTie0: tied to zero. Only the 0-th aig pin is allowed to \xe2\x80\xa6AaWarn and continueBfThe D input pin with invert (last bit)BjData payload for $display format argumentsBhDestination port path (e.g., \xe2\x80\x9ci0.A\xe2\x80\x9d)BkThe D flip-flops (DFFs), indexed by cell idAoReturns the argument unchanged.00000000000000000000000000000000000Aibuild a flattened script.111111111111111111111111111111111111111111AnGPIO index driving this clock.Ckthe boomerang hierarchy, 8192 -&gt; 4096 -&gt; \xe2\x80\xa6 -&gt; 1.BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000BkIterate over events without consuming them.nPrimitive namehPin nameiCell namelLibrary nameCeHuman-readable name for this clock domain (optional).AlDisplay name for the signal.BiPin timing information, keyed by pin nameA`Truth table rowsCkStep the UART monitor with the current TX pin value and \xe2\x80\xa6BdUDP models indexed by primitive nameChA single event written by the GPU. Layout must match \xe2\x80\xa6BlMixed cells from both libraries (error case)BePause simulation (for $stop or debug)AmPause simulation (like $stop)CmAlignment: \xe2\x80\x98&lt;\xe2\x80\x99 left, \xe2\x80\x98&gt;\xe2\x80\x99 right, \xe2\x80\x98^\xe2\x80\x99 center.BhCells in the library, keyed by cell nameClNumber of events currently in the buffer (atomic for GPU \xe2\x80\xa6BhSimulation cycle when the event occurredCnDrain all events from the buffer, processing each with the \xe2\x80\xa6CiIf the DFF is enabled, i.e., if the clock, S, or R is \xe2\x80\xa6AlGate instantiations in orderBdParse Liberty content from a string.CiDisplay format: \xe2\x80\x98d\xe2\x80\x99 decimal, \xe2\x80\x98h\xe2\x80\x99 hex, \xe2\x80\x98b\xe2\x80\x99 \xe2\x80\xa6BaReset the buffer for a new cycle.CkDesign loading pipeline: netlist \xe2\x86\x92 AIG \xe2\x86\x92 staged \xe2\x86\x92 \xe2\x80\xa6AmThe SRAMs, indexed by cell idAjBit width of the argument.CeWidth for bundle signals (e.g., 32 for a 32-bit bus).AeAIGPDK standard cellsBkMulti-bit bundle (pins ordered LSB to MSB).An$finish - terminate simulationBj$finish system task - terminate simulationAfSKY130 open-source PDKBbA single row in a UDP truth table.ChAIGPDK is a special artificial cell library used in GEM.CiMulti-clock domain configuration. When set, overrides \xe2\x80\xa6oThe event arrayBbThe format string for this displayBlFormat string from the gem_format attribute.CfFormat for output: \xe2\x80\x9cbin\xe2\x80\x9d, \xe2\x80\x9chex\xe2\x80\x9d, or \xe2\x80\x9cdec\xe2\x80\x9d.B`Input wire names (in port order)CnModule input port names (e.g. [\xe2\x80\x9cA1\xe2\x80\x9d, \xe2\x80\x9cA2\xe2\x80\x9d, \xe2\x80\x9cB1\xe2\x80\x9d\xe2\x80\xa6CiInput values: Some(true)=1, Some(false)=0, None=don\xe2\x80\x99\xe2\x80\xa6AiInput port names in orderCmGPIO index \xe2\x86\x92 input port name (external signals entering \xe2\x80\xa6ClBehavioral models indexed by cell type (e.g. \xe2\x80\x9co21ai\xe2\x80\x9d \xe2\x80\xa6A`Output wire namelOutput valueA`Output port nameAlWhether the value is signed.BmSKY130 standard cell library support for GEM.C`Source port path (e.g., \xe2\x80\x9cdff_in.Q\xe2\x80\x9d or \xe2\x80\x9c\xe2\x80\xa6Aethe boomerang stages.CgTiming simulation configuration for post-layout SDF \xe2\x80\xa6CePack into a single u32 for GPU transfer. Format: [\xe2\x80\xa6BjVCD input/output utilities for simulation.AfDriven by an and gate.B`$display/$write output (Phase 2)AmA cell entry in the SDF file.A`Parsed SDF file.BhHierarchical name representation in VCD.BnThe argument signals (each entry is aigpin_iv)BaDFF cell ID (for error reporting)AmThe driver types of AIG pins.AnCell fall delay in picosecondsAeThe fanout CSR array.BaPartition scheduler and flattenerAhHold time in picosecondsBn(aigpin, output_pos_in_state, vcd_variable_id)BiModule output port names (e.g. [\xe2\x80\x9cY\xe2\x80\x9d])CjGPIO index \xe2\x86\x92 output port name (signals driven by the \xe2\x80\xa6AnCell rise delay in picosecondsChSet a pin value by name. Returns true if the pin was \xe2\x80\xa6ClSplitting deep circuit into major stages at global level \xe2\x80\xa6BdSummary statistics for debug output.AlContinue simulation normallyDeA ram block resembling the interface of <code>$__RAMGEM_SYNC_</code>.BkDelay value in picoseconds (rise and fall).BeStatistics tracked during simulation.BnA parsed Verilog UDP (User Defined Primitive).BiThe clock enable signal (posedge trigger)mData pin nameCgThe display nodes ($display/$write), indexed by cell idAbUnpack from a u32.CdCreate a PackedDelay from u64 picosecond values, \xe2\x80\xa6AnGet timing for a cell by name.B`Look up a cell by instance path.CaInstance path (empty string for top-level module)AkWhether this pin is a clockBcLoad SDF timing data into a script.AkGet maximum hold time (ps).CfFlag indicating if events were dropped due to overflowBcPad character (\xe2\x80\x980\xe2\x80\x99 or \xe2\x80\x99 \xe2\x80\x99).CcPath to SDF file from OpenLane2 (e.g. 6_final.sdf).AiSetup time in picosecondsAoConstraint value in picosecondsAfDFF timing parameters.BlEvent types that can be reported by the GPU.CgDriven by a primary input port (with its netlistdb id).CeOne partitioned block: a basic execution unit on GPU.CcCollection of loaded PDK models for a cell library.BdTiming information for a single pin.BmWhich corner of (min:typ:max) triples to use.ChAn IOPATH delay entry: input_pin \xe2\x86\x92 output_pin with \xe2\x80\xa6CeA struct representing the boundaries of a staged AIG.CeTerminate simulation (for $finish or fatal assertion)AdTerminate simulationBcTerminate simulation (like $finish)BnTiming arc from an input pin to an output pin.AcDecoded UART event.AnUART TX decoder state machine.BiWatchlist configuration loaded from JSON.AnReserved for padding/alignmentAfReserved for alignmentCkSequence of AND gate operations to build. Each entry is \xe2\x80\xa6BdGet delay for the buffer cell (BUF).Chbuild one partition given a set of endpoints to realize.CaThe cell name (for matching with JSON attributes)CiPin direction (\xe2\x80\x9cinput\xe2\x80\x9d, \xe2\x80\x9coutput\xe2\x80\x9d, \xe2\x80\x9cinternal\xe2\x80\x9d)CiEdge type per position: 0 = any, 1 = rising, 2 = falling.CnThe enable condition input pin with invert (last bit) When \xe2\x80\xa6Cmthe endpoint indices of original AIG fulfilled by current \xe2\x80\xa6Cbthe endpoints that are realized by this partition.BhLoad a Liberty library from a file path.CmGate type: \xe2\x80\x9cand\xe2\x80\x9d, \xe2\x80\x9cor\xe2\x80\x9d, \xe2\x80\x9cnand\xe2\x80\x9d, \xe2\x80\x9cnor\xe2\x80\x9d, \xe2\x80\x9c\xe2\x80\xa6BoGet the packed delay for an AIG pin (by index).CeGet hold time for data pin relative to clock (for \xe2\x80\xa6Ckmaps from primary inputs, FF:Q/SRAM:* input AIG pins to \xe2\x80\xa6BfGet delay for the inverter cell (INV).BnPath to JSON file with display format strings.CcGet the maximum delay (for critical path analysis).AlGet maximum setup time (ps).BdMinimum display width (for padding).B`Parse an SDF file from a string.BiParse a Verilog UDP primitive definition.BlRun mt-kahypar to partition this hypergraph.CcClock period in picoseconds (e.g. 40000 for 25MHz).CfShared testbench infrastructure for timing and GPU \xe2\x80\xa6AkTime unit (e.g., \xe2\x80\x9c1ps\xe2\x80\x9d)AkAssertion failure (Phase 3)CmFixed-size struct for collecting input pins during SKY130 \xe2\x80\xa6AnTiming information for a cell.B`Parameters for loading a design.AnThe driver type of an AIG pin.CnParse a Yosys format string and extract format specifiers. \xe2\x80\xa6ClMaximum number of events that can be buffered per cycle. \xe2\x80\xa6AgSRAM timing parameters.CkWhat action the simulation should take after processing \xe2\x80\xa6AoThe bit widths of each argumentCeArgument width in bits from gem_args_width attribute.Ai\xe2\x80\x9cSETUP\xe2\x80\x9d or \xe2\x80\x9cHOLD\xe2\x80\x9dCbClock edge specification (e.g., \xe2\x80\x9cposedge CLK\xe2\x80\x9d)CkGet clock-to-Q delay for output pin (for sequential cells).BkDFF timing constraints loaded from Liberty.AkGet DFF timing information.CgEvent type (see EventType enum) - u32 for GPU alignmentCibuild a staged AIG by vertical splitting at the given \xe2\x80\xa6BbCheck if timing data is available.BhOptional message ID for display purposesCnMessage ID for $display and assertions (index into message \xe2\x80\xa6Adthe number of blocksBcAction to take on assertion failureCkIndex of the final output (-1 = first gate, -2 = second \xe2\x80\xa6Ckmaps from primary outputs, FF:D and SRAM:PORT_R_RD_DATA \xe2\x80\xa6BcParse an SDF file from a file path.CiSDF corner selection: \xe2\x80\x9cmin\xe2\x80\x9d, \xe2\x80\x9ctyp\xe2\x80\x9d, or \xe2\x80\x9cmax\xe2\x80\x9d.CaParser for Standard Delay Format (SDF) 3.0 files.CfGet setup time for data pin relative to clock (for \xe2\x80\xa6CiSKY130 PDK behavioral model parser and AIG decomposition.AeNumber of $stop callsCnthe 32-packed elements in the hierarchy where there should \xe2\x80\xa6AoThe detected cell library type.BhConfiguration for a single clock domain.BlSafe wrapper around the C++ SPI flash model.CjA display node for $display/$write system tasks. These \xe2\x80\xa6CjThe event buffer structure shared between GPU and CPU. \xe2\x80\xa6CiPacked delay representation for GPU consumption. Uses \xe2\x80\xa6ClMaps GPIO indices to netlist port names for designs with \xe2\x80\xa6CfUART TX monitor that decodes serial output into bytes.Akthe partition instructions.ClGate delays for each AIG pin: (rise_ps, fall_ps). Loaded \xe2\x80\xa6CnPer-AIG-pin delays loaded from Liberty library. Index 0 is \xe2\x80\xa6DgHold slack for each DFF (indexed by position in <code>dffs</code>). \xe2\x80\xa6CcCheck if a cell is a tie cell (constant generator).CkLoad the default AIGPDK library from the standard location.ClLoad a design through the full pipeline: netlist \xe2\x86\x92 AIG \xe2\x80\xa6C`Load timing data from a Liberty library and AIG.BoModule name (e.g. \xe2\x80\x9csky130_fd_sc_hd__o21ai\xe2\x80\x9d)AgThe number of AIG pins.AhRelated (input) pin nameAmSignal type (reg, comb, mem).ClThe simulation control nodes ($stop/$finish), indexed by \xe2\x80\xa6AlGet SRAM timing information.AlTiming arcs from/to this pinCmTiming type (e.g., \xe2\x80\x9csetup_rising\xe2\x80\x9d, \xe2\x80\x9chold_rising\xe2\x80\x9d, \xe2\x80\xa6CnPack into two u32s for GPU transfer. Returns (timing_word, \xe2\x80\xa6BgAction to take when an assertion fails.CcConfiguration for how assertions should be handled.CaResult of decomposing a cell into AIG operations.CeResult of loading a design: everything needed for \xe2\x80\xa6BnAction to take when a timing violation occurs.CkConfiguration for timing violation handling (Experiment 4).BcSummary of timing analysis results.AfAddress hold time (ps)Bkthe CSR start indices of stages and blocks.AnCell fall delay in picosecondsAnCell rise delay in picosecondsClThe condition input pin with invert (last bit) When this \xe2\x80\xa6BaThe control type (Stop or Finish)CbGet DFFSR (DFF with set/reset) timing information.BoEvent buffer for GPU\xe2\x86\x92CPU communication of \xe2\x80\xa6CaCheck if any events were dropped due to overflow.BjHold time for falling data transition (ps)BiHold time for rising data transition (ps)Anexpected input AIG pins layoutCkFlattened input state vectors, one per cycle + trailing \xe2\x80\xa6CbQuick lookup: instance path \xe2\x86\x92 index in cells vecBbGet maximum clock-to-Q delay (ps).CfMaximum number of failures before stopping (None = \xe2\x80\xa6AbMake an edge list.BbAction to take on timing violationCjMaps GPIO indices to actual port names in the netlist. \xe2\x80\xa6Ckcontrols whether r_rd_data should update. (from read clock)DhSetup slack for each DFF (indexed by position in <code>dffs</code>). \xe2\x80\xa6BhDFF timing constraints for GPU checking.CmA type of endpoint group. can be a primary output-related \xe2\x80\xa6BbHold time violation (Experiment 4)DkGPU-side monitor descriptor (must match Metal <code>MonitorConfig</code>\xe2\x80\xa6CeA Liberty timing library containing cell timing data.CkA reusable topological traverser with dense visited buffer.AgAddress setup time (ps)CnArrival times for each AIG pin: (min_ps, max_ps). Computed \xe2\x80\xa6CaCPU-side partition executor for script version 1.AkThe fanout CSR start array.Bobuild a staged AIG that consists of all levels.CgNumber of timing endpoints analyzed (DFFs + primary \xe2\x80\xa6BoThe mapping from a netlistdb pin to an AIG pin.BkSetup time for falling data transition (ps)BjSetup time for rising data transition (ps)CbPerform a topological traversal, equivalent to \xe2\x80\xa6CmThis implements direction and width providers for AIG PDK \xe2\x80\xa6CiA single gate instantiation from a functional Verilog \xe2\x80\xa6AcOne Boomerang stageCmDriven by a clock flag (with clock port netlistdb id, and \xe2\x80\xa6ClResult of parsing input VCD: the state vectors and cycle \xe2\x80\xa6CiLeafPinProvider implementation for SKY130 standard cells.CbA TIMINGCHECK entry for setup or hold constraints.BcSetup time violation (Experiment 4)CmA simulation control node for $stop/$finish system tasks. \xe2\x80\xa6BnSimulation control type for $stop and $finish.DhReverse iterator of a <code>VCDHier</code>, yielding cell names from \xe2\x80\xa6CgResolved watchlist entry - either single bit or bundle.B`A cache for identical and gates.ChGet combinational delay for an AND gate variant. The \xe2\x80\xa6CaCompute static timing analysis (STA) for the AIG.CkConstant port values: port name \xe2\x86\x92 value (0 or 1). For \xe2\x80\xa6BiPosition of D input data arrival in stateCiCreate a TimingLibrary with default SKY130 timing values.BoDetect which cell library is used in a netlist.BhNumber of events dropped due to overflowBnFind a scope by its path in the VCD hierarchy.CiEnumerate all related aigpin inputs for this endpoint \xe2\x80\xa6AnBuild an AIG from a netlistdb.C`Returns true if there are any timing violations.BgCheck if a cell name is an AIGPDK cell.CeCheck if a cell name is a SKY130 standard cell or \xe2\x80\xa6CkSimple Liberty (.lib) parser for extracting timing data \xe2\x80\xa6ChMaximum number of violations before stopping (None = \xe2\x80\xa6Bothe staged primary inputs from previous levels.CkProcess events from the buffer and determine simulation \xe2\x80\xa6BdWhether timing data has been loaded.BmA parsed functional Verilog model for a cell.CmInformation about a GEM_DISPLAY cell extracted from Yosys \xe2\x80\xa6CeAn INTERCONNECT delay entry: source \xe2\x86\x92 dest with \xe2\x80\xa6BiTestbench configuration loaded from JSON.ClConfiguration for post-layout timing simulation with SDF \xe2\x80\xa6BcWatchlist signal entry (from JSON).CkClock period in picoseconds for SDF timing. Defaults to \xe2\x80\xa6CgClock period in picoseconds (for STA calculations). \xe2\x80\xa6BnClock period in picoseconds for timing checks.ClClock period in picoseconds (e.g. 40000 for 25MHz). Used \xe2\x80\xa61CiConstant input values: GPIO index \xe2\x86\x92 value (0 or 1). \xe2\x80\xa6ClDelay injection info for GPU kernel. Each entry: (offset \xe2\x80\xa6CmDFF timing constraints for setup/hold checking. One entry \xe2\x80\xa6AiNumber of hold violationsBoNumber of hold timing violations (Experiment 4)CcLoad all PDK models needed for a set of cell types.BbWhether to invert the final outputCgParse input VCD flow into state vectors for simulation.ChPhase offset in picoseconds from time zero (default: 0).Bjcontrols whether memory should be updated.BdUnique primary output aigpin indicesBgState bit positions to watch for edges.BgInformation needed to write output VCD.BhClock-to-Q delay for falling output (ps)BgClock-to-Q delay for rising output (ps)BjReturn the effective clock configurations.CkTry to match one component in a scope path. Returns the \xe2\x80\xa6BkMatch VCD variables to netlist input ports.Ajthe number of major stagesCjRun CPU sanity check comparing GPU results against CPU \xe2\x80\xa6ClSet up output VCD writer: add wire definitions and build \xe2\x80\xa6AjNumber of setup violationsC`Number of setup timing violations (Experiment 4)BgWorst hold slack (negative = violation)BgWrite simulation results to output VCD.CmA flattened script, for partition executor version 1. See \xe2\x80\xa6CkGPU\xe2\x86\x94CPU peripheral callback control block (must match \xe2\x80\xa6CkDescribes a GPIO output to watch for edges on the GPU side.CjOR bitset <code>src</code> into <code>dst</code> in-place.ChGiven the level split points, return a list of split \xe2\x80\xa6CkThe clock pins map. Every clock pin has a pair of flag pinsClMaps from display cell IDs to their enable positions and \xe2\x80\xa6BoExtract the cell type from a SKY130 macro name.Cathe state size including DFF and I/O states only.CfResolve the top scope from VCD header, either from \xe2\x80\xa6CfCPU prototype partition executor for script version 1.Bgthe u32 array length for storing SRAMs.BhWorst setup slack (negative = violation)BhNumber of assertion failures encounteredCdRecursively collect all scope paths from VCD header.BbDecompose a cell using PDK models.BoFall constraint (for setup/hold) in picosecondsCgGet the critical path endpoints (nodes with longest \xe2\x80\xa6BmGet the virtual endpoint group with an index.ChCheck if a cell type is a sequential element (DFF or \xe2\x80\xa6Cd(offset_into_input_states, vcd_timestamp) per cycle.CfGiven an initial clustering solution of endpoints, \xe2\x80\xa6BoRise constraint (for setup/hold) in picosecondsCmbuild a staged AIG by horizontal splitting given a subset \xe2\x80\xa6AiWrite data hold time (ps)CfMaps AIG pin index \xe2\x86\x92 list of (netlistdb cell_id, \xe2\x80\xa6CmMaps from assertion cell IDs to their condition positions \xe2\x80\xa6BbCritical path delay in picosecondsBoLoad timing information from a Liberty library.CnGet the number of endpoint groups that should be fulfilled \xe2\x80\xa6CkParse Yosys format string into literal parts and format \xe2\x80\xa6Bothe staged primary output pins for next levels.Ci(for debug purpose) the relation between major stage, \xe2\x80\xa6BnTrace back the critical path from an endpoint.AjWrite data setup time (ps)AoThe number of boomerang stages.CcCheck if a cell has multiple outputs (like adders).CbLoad timing from an SDF file with per-instance \xe2\x80\xa6BiAuto-detect VCD scope containing the DUT.CaCompute the popcount of the union of two bitsets.CmDirectly evaluate a behavioral model\xe2\x80\x99s gate network for \xe2\x80\xa6CmPopulate display format information from JSON attributes. \xe2\x80\xa6AjThe addr width of an SRAM.ChFormat a display message given the format string and \xe2\x80\xa6CgParse a functional Verilog model file (*.functional.v).CeBuild an AIG from a netlistdb, using explicit PDK \xe2\x80\xa6ClInject timing delay data into the GPU script\xe2\x80\x99s padding \xe2\x80\xa6ClGet the maximum propagation delay through this cell (for \xe2\x80\xa6CjBuild timing constraint buffer for GPU-side setup/hold \xe2\x80\xa6CkDetect library from a Verilog file by scanning for cell \xe2\x80\xa6BmGet required input port names from netlistdb.BiRead clock to data output fall delay (ps)BiRead clock to data output rise delay (ps)CmConvert a parsed behavioral model to an AIG decomposition \xe2\x80\xa6CmPerform a topological traversal and also produce a bitset \xe2\x80\xa6CaCheck if a VCD scope contains all required ports.CgMaximum number of timing violations before stopping \xe2\x80\xa6CjBuild a per-word timing constraint buffer for GPU-side \xe2\x80\xa6ClExtract display cell information from a Yosys JSON file. \xe2\x80\xa6ClRead a cluster solution from hgr.part.xx file. Then call \xe2\x80\xa6")