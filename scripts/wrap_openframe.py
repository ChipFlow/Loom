#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = []
# ///
"""Wrap a synthesized 'top' module netlist in openframe_project_wrapper.

Reads pins.lock to map individual IO ports to GPIO bus indices, then
generates an openframe_project_wrapper that instantiates the 'top' module
with proper GPIO bus connections.

Usage:
    uv run scripts/wrap_openframe.py <pins.lock> <top_synth.v> <6_final.v>
"""

from __future__ import annotations

import json
import re
import sys
from pathlib import Path


def parse_pins_lock(path: Path) -> dict:
    """Parse pins.lock and return signal-to-GPIO mappings."""
    with open(path) as f:
        data = json.load(f)

    mappings = {}  # port_name -> {gpio_indices, direction, width, ...}

    def walk(obj, path_parts=None):
        if path_parts is None:
            path_parts = []
        if not isinstance(obj, dict):
            return
        if "type" in obj and obj["type"] == "io":
            port_name = obj["port_name"]
            iomodel = obj.get("iomodel", {})
            direction = iomodel.get("direction", "io")
            width = iomodel.get("width", 1)
            individual_oe = iomodel.get("individual_oe", False)

            gpio_indices = []
            for pin_entry in obj.get("pins", []):
                if pin_entry[1] == "gpio":
                    gpio_indices.append(pin_entry[2])

            if gpio_indices:
                mappings[port_name] = {
                    "gpio_indices": sorted(gpio_indices),
                    "direction": direction,
                    "width": width,
                    "individual_oe": individual_oe,
                }
        elif "type" in obj and obj["type"] in ("clock", "reset"):
            # Bringup pins (clock, reset)
            port_name = obj["port_name"]
            iomodel = obj.get("iomodel", {})
            direction = iomodel.get("direction", "i")

            gpio_indices = []
            for pin_entry in obj.get("pins", []):
                if pin_entry[1] == "gpio":
                    gpio_indices.append(pin_entry[2])

            if gpio_indices:
                mappings[f"__bringup__{port_name}"] = {
                    "gpio_indices": sorted(gpio_indices),
                    "direction": direction,
                    "width": 1,
                    "bringup_name": port_name,
                }
        else:
            for key, val in obj.items():
                if key not in ("type", "pins", "port_name", "iomodel"):
                    walk(val, path_parts + [key])

    port_map = data.get("port_map", {}).get("ports", {})
    walk(port_map)

    # Bringup pins
    bringup = data.get("port_map", {}).get("bringup_pins", {})
    if bringup:
        for name, info in bringup.items():
            if isinstance(info, dict) and "pin" in info:
                pin_entry = info["pin"]
                gpio_idx = pin_entry[2]
                mappings[f"__bringup__{name}"] = {
                    "gpio_indices": [gpio_idx],
                    "direction": "i",
                    "width": 1,
                    "bringup_name": name,
                }

    return mappings


def parse_top_ports(synth_v: Path) -> list[dict]:
    """Parse the top module's port declarations from synthesized Verilog."""
    ports = []
    with open(synth_v) as f:
        content = f.read()

    # Find input/output declarations
    for match in re.finditer(
        r'(input|output)\s+(\[(\d+):(\d+)\]\s+)?(\\[^\s;]+)',
        content[:10000]  # Only scan first 10KB for port declarations
    ):
        direction = match.group(1)
        msb = int(match.group(3)) if match.group(3) else 0
        lsb = int(match.group(4)) if match.group(4) else 0
        name = match.group(5)
        width = msb - lsb + 1 if msb >= lsb else 1

        ports.append({
            "name": name,
            "direction": direction,
            "width": width,
            "msb": msb,
            "lsb": lsb,
        })

    return ports


def generate_wrapper(mappings: dict, top_ports: list[dict]) -> str:
    """Generate openframe_project_wrapper Verilog."""

    # Build set of existing top module port names for checking existence
    existing_ports = set()
    for port in top_ports:
        existing_ports.add(port["name"])

    lines = []
    lines.append("// Generated by wrap_openframe.py")
    lines.append("// Wraps synthesized 'top' module in openframe_project_wrapper")
    lines.append("")
    lines.append("module openframe_project_wrapper (")
    lines.append("    por_l,")
    lines.append("    porb_h,")
    lines.append("    porb_l,")
    lines.append("    resetb_h,")
    lines.append("    resetb_l,")
    lines.append("    analog_io,")
    lines.append("    analog_noesd_io,")
    lines.append("    gpio_analog_en,")
    lines.append("    gpio_analog_pol,")
    lines.append("    gpio_analog_sel,")
    lines.append("    gpio_dm0,")
    lines.append("    gpio_dm1,")
    lines.append("    gpio_dm2,")
    lines.append("    gpio_holdover,")
    lines.append("    gpio_ib_mode_sel,")
    lines.append("    gpio_in,")
    lines.append("    gpio_in_h,")
    lines.append("    gpio_inp_dis,")
    lines.append("    gpio_loopback_one,")
    lines.append("    gpio_loopback_zero,")
    lines.append("    gpio_oeb,")
    lines.append("    gpio_out,")
    lines.append("    gpio_slow_sel,")
    lines.append("    gpio_vtrip_sel,")
    lines.append("    mask_rev")
    lines.append(");")
    lines.append("  input por_l;")
    lines.append("  input porb_h;")
    lines.append("  input porb_l;")
    lines.append("  input resetb_h;")
    lines.append("  input resetb_l;")
    lines.append("  inout [43:0] analog_io;")
    lines.append("  inout [43:0] analog_noesd_io;")
    lines.append("  output [43:0] gpio_analog_en;")
    lines.append("  output [43:0] gpio_analog_pol;")
    lines.append("  output [43:0] gpio_analog_sel;")
    lines.append("  output [43:0] gpio_dm0;")
    lines.append("  output [43:0] gpio_dm1;")
    lines.append("  output [43:0] gpio_dm2;")
    lines.append("  output [43:0] gpio_holdover;")
    lines.append("  output [43:0] gpio_ib_mode_sel;")
    lines.append("  input [43:0] gpio_in;")
    lines.append("  input [43:0] gpio_in_h;")
    lines.append("  output [43:0] gpio_inp_dis;")
    lines.append("  input [43:0] gpio_loopback_one;")
    lines.append("  input [43:0] gpio_loopback_zero;")
    lines.append("  output [43:0] gpio_oeb;")
    lines.append("  output [43:0] gpio_out;")
    lines.append("  output [43:0] gpio_slow_sel;")
    lines.append("  output [43:0] gpio_vtrip_sel;")
    lines.append("  input [31:0] mask_rev;")
    lines.append("")

    # Default control signal assignments
    lines.append("  // Default control signals")
    lines.append("  assign gpio_analog_en = 44'b0;")
    lines.append("  assign gpio_analog_pol = 44'b0;")
    lines.append("  assign gpio_analog_sel = 44'b0;")
    lines.append("  assign gpio_holdover = 44'b0;")
    lines.append("  assign gpio_slow_sel = 44'b0;")
    lines.append("  assign gpio_inp_dis = 44'b0;")
    lines.append("")

    # Create internal wires for top module ports
    lines.append("  // Internal wires for top module connections")
    for port in top_ports:
        if port["width"] > 1:
            lines.append(f"  wire [{port['msb']}:{port['lsb']}] {port['name']} ;")
        else:
            lines.append(f"  wire {port['name']} ;")
    lines.append("")

    # GPIO input connections
    lines.append("  // GPIO input -> top module input connections")
    used_in_gpio = set()
    used_out_gpio = set()
    used_oeb_gpio = set()

    for port_name, info in mappings.items():
        bringup_name = info.get("bringup_name")
        gpio_indices = info["gpio_indices"]
        direction = info["direction"]
        width = info["width"]

        if bringup_name:
            # Bringup pins: clk, rst_n
            gpio_idx = gpio_indices[0]
            io_port = f"\\io${bringup_name}$i"
            lines.append(f"  assign {io_port}  = gpio_in[{gpio_idx}]; // bringup: {bringup_name}")
            used_in_gpio.add(gpio_idx)
            continue

        # Regular IO ports
        if width == 1:
            gpio_idx = gpio_indices[0]
            if direction in ("i", "io"):
                io_port = f"\\io${port_name}$i"
                lines.append(f"  assign {io_port}  = gpio_in[{gpio_idx}]; // {port_name} input")
                used_in_gpio.add(gpio_idx)
            if direction in ("o", "io"):
                io_port = f"\\io${port_name}$o"
                lines.append(f"  assign gpio_out[{gpio_idx}] = {io_port} ; // {port_name} output")
                used_out_gpio.add(gpio_idx)
                oe_port = f"\\io${port_name}$oe"
                lines.append(f"  assign gpio_oeb[{gpio_idx}] = ~( {oe_port} ); // {port_name} OEB")
                used_oeb_gpio.add(gpio_idx)
        else:
            # Multi-bit port
            base_gpio = min(gpio_indices)
            if direction in ("i", "io"):
                for gpio_idx in gpio_indices:
                    bit = gpio_idx - base_gpio
                    io_port = f"\\io${port_name}$i"
                    lines.append(f"  assign {io_port} [{bit}] = gpio_in[{gpio_idx}]; // {port_name}[{bit}] input")
                    used_in_gpio.add(gpio_idx)
            if direction in ("o", "io"):
                individual_oe = info.get("individual_oe", False)
                for gpio_idx in gpio_indices:
                    bit = gpio_idx - base_gpio
                    io_port = f"\\io${port_name}$o"
                    lines.append(f"  assign gpio_out[{gpio_idx}] = {io_port} [{bit}]; // {port_name}[{bit}] output")
                    used_out_gpio.add(gpio_idx)
                    oe_port = f"\\io${port_name}$oe"
                    if individual_oe:
                        lines.append(f"  assign gpio_oeb[{gpio_idx}] = ~( {oe_port} [{bit}] ); // {port_name}[{bit}] OEB")
                    else:
                        lines.append(f"  assign gpio_oeb[{gpio_idx}] = ~( {oe_port} ); // {port_name} OEB")
                    used_oeb_gpio.add(gpio_idx)
    lines.append("")

    # Drive mode connections (only for ports that exist in synthesized design)
    lines.append("  // Drive mode connections (dm0/dm1/dm2)")
    used_dm_gpio = set()
    for port_name, info in mappings.items():
        if info.get("bringup_name"):
            continue
        gpio_indices = info["gpio_indices"]
        width = info["width"]
        dm0_name = f"\\io${port_name}$dm0"
        if dm0_name not in existing_ports:
            continue  # Port doesn't exist in synthesized design
        if width == 1:
            gpio_idx = gpio_indices[0]
            dm0 = f"\\io${port_name}$dm0"
            dm1 = f"\\io${port_name}$dm1"
            dm2 = f"\\io${port_name}$dm2"
            lines.append(f"  assign gpio_dm0[{gpio_idx}] = {dm0} ;")
            lines.append(f"  assign gpio_dm1[{gpio_idx}] = {dm1} ;")
            lines.append(f"  assign gpio_dm2[{gpio_idx}] = {dm2} ;")
            used_dm_gpio.add(gpio_idx)
        else:
            base_gpio = min(gpio_indices)
            for gpio_idx in gpio_indices:
                bit = gpio_idx - base_gpio
                dm0 = f"\\io${port_name}$dm0"
                dm1 = f"\\io${port_name}$dm1"
                dm2 = f"\\io${port_name}$dm2"
                lines.append(f"  assign gpio_dm0[{gpio_idx}] = {dm0} [{bit}];")
                lines.append(f"  assign gpio_dm1[{gpio_idx}] = {dm1} [{bit}];")
                lines.append(f"  assign gpio_dm2[{gpio_idx}] = {dm2} [{bit}];")
                used_dm_gpio.add(gpio_idx)
    lines.append("")

    # IE and vtrip_sel connections (only for ports that exist in synthesized design)
    lines.append("  // Input enable and voltage trip connections")
    used_ib_gpio = set()
    for port_name, info in mappings.items():
        bringup_name = info.get("bringup_name")
        gpio_indices = info["gpio_indices"]
        direction = info["direction"]
        width = info["width"]

        # Only inputs and bidirectional have IE
        if direction not in ("i", "io") and not bringup_name:
            continue

        actual_name = bringup_name if bringup_name else port_name
        ib_name = f"\\io${actual_name}$ib_mode_sel"
        if ib_name not in existing_ports:
            continue  # Port doesn't exist in synthesized design

        if width == 1:
            gpio_idx = gpio_indices[0]
            ib_port = f"\\io${actual_name}$ib_mode_sel"
            vt_port = f"\\io${actual_name}$vtrip_sel"
            lines.append(f"  assign gpio_ib_mode_sel[{gpio_idx}] = {ib_port} ;")
            lines.append(f"  assign gpio_vtrip_sel[{gpio_idx}] = {vt_port} ;")
            used_ib_gpio.add(gpio_idx)
        else:
            base_gpio = min(gpio_indices)
            for gpio_idx in gpio_indices:
                bit = gpio_idx - base_gpio
                ib_port = f"\\io${port_name}$ib_mode_sel"
                vt_port = f"\\io${port_name}$vtrip_sel"
                lines.append(f"  assign gpio_ib_mode_sel[{gpio_idx}] = {ib_port} [{bit}];")
                lines.append(f"  assign gpio_vtrip_sel[{gpio_idx}] = {vt_port} [{bit}];")
                used_ib_gpio.add(gpio_idx)
    lines.append("")

    # Default unused GPIO
    lines.append("  // Default unused GPIO pins")
    for i in range(44):
        if i not in used_out_gpio:
            lines.append(f"  assign gpio_out[{i}] = 1'b0;")
        if i not in used_oeb_gpio:
            lines.append(f"  assign gpio_oeb[{i}] = 1'b1; // disabled")
        if i not in used_dm_gpio:
            lines.append(f"  assign gpio_dm0[{i}] = 1'b0;")
            lines.append(f"  assign gpio_dm1[{i}] = 1'b0;")
            lines.append(f"  assign gpio_dm2[{i}] = 1'b0;")
        if i not in used_ib_gpio:
            lines.append(f"  assign gpio_ib_mode_sel[{i}] = 1'b0;")
            lines.append(f"  assign gpio_vtrip_sel[{i}] = 1'b0;")
    lines.append("")

    # Instantiate top module
    lines.append("  // Instantiate synthesized design")
    port_conns = []
    for port in top_ports:
        port_conns.append(f"    .{port['name']} ({port['name']} )")

    lines.append("  top top_inst (")
    lines.append(",\n".join(port_conns))
    lines.append("  );")
    lines.append("")
    lines.append("endmodule")

    return "\n".join(lines)


def main():
    if len(sys.argv) != 4:
        print(f"Usage: {sys.argv[0]} <pins.lock> <top_synth.v> <6_final.v>")
        sys.exit(1)

    pins_lock_path = Path(sys.argv[1])
    synth_v_path = Path(sys.argv[2])
    output_path = Path(sys.argv[3])

    print(f"Reading pins.lock from {pins_lock_path}")
    mappings = parse_pins_lock(pins_lock_path)

    print(f"Pin mappings:")
    for name, info in sorted(mappings.items(), key=lambda x: x[1]["gpio_indices"][0]):
        bringup = info.get("bringup_name", "")
        label = bringup if bringup else name
        print(f"  GPIO[{info['gpio_indices']}]: {label} ({info['direction']})")

    print(f"Parsing ports from {synth_v_path}")
    top_ports = parse_top_ports(synth_v_path)
    print(f"  Found {len(top_ports)} ports")

    print(f"Generating wrapper...")
    wrapper = generate_wrapper(mappings, top_ports)

    print(f"Writing {output_path}")
    with open(synth_v_path) as f:
        synth_content = f.read()

    with open(output_path, "w") as f:
        f.write(wrapper)
        f.write("\n\n")
        f.write(synth_content)

    print(f"Done! Size: {output_path.stat().st_size / 1024:.0f} KB")


if __name__ == "__main__":
    main()
